{"./":{"url":"./","title":"信鸽推送基础介绍","keywords":"","body":"信鸽推送基础介绍 信鸽提供什么样的服务？ 在移动应用的开发和运营过程中，推送消息（Push Notification）是非常重要的用户触达手段，通过推送消息可以形成和用户的互动，进一步带来产品使用度的提升。 信鸽帮助开发者集成移动推送能力，管理推送消息，衡量推送效果。 1.1.信鸽 PUSH SDK 信鸽提供了全链路的移动推送能力，只需接入信鸽的SDK（10分钟即可完成接入，点击这里查看教程），就可以立即将推送消息送达到用户的移动设备。 1.2.信鸽网页管理台 同时，信鸽还提供了操作便捷的网页端管理台，方便开发者进行推送消息管理，推送数据查看，推送调试。您只需要进行简单的配置，即可发送消息，并且实时的观测数据 1.3.高级定制API 为了帮助您灵活的定制推送相关业务逻辑，信鸽也提供了全面的终端和后台API，通过这些API您可以实现个性化的触达等高级使用场景 信鸽推送流程总览 在这个部分，我们将介绍信鸽推送的流程，包含「消息下发」和「数据上报」两个链路。 基本概念解释 3.1.概述 在这个部分中给出信鸽服务中部分「基本概念」的释义， 阅读这个部分可以帮助您更好的理解信鸽服务，以及其他文档。 3.2.消息类型 [通知栏消息] 由操作系统展现在通知栏的消息，用户可以点击消息并且打开应用 [应用内消息] 直接透传给Android终端的消息，不会主动展示在通知栏，由App在接受后进行处理 3.3.推送通道 [Android 厂商通道] 由 Android 手机厂商提供的系统级推送通道，可以实现不启动应用就接收并展现消息。当前国内主流手机厂商均推出了这项服务，详细的介绍请请见Android厂商通道 [APNs] Apple Push Notification Service 的缩写，iOS 系统推送通道。所有的 iOS 推送消息均通过 APNs 下发到设备 [Android 信鸽通道] 信鸽推送自建的推送通道，通过特有的共享通道机制，维持设备和信鸽服务器间的连接，以保障推送消息的触达 [FCM通道] FCM是 FireBase Cloud Messaging 的缩写，是由 Google 官方推出的推送服务&通道，在海外场景下具备系统级推送的能力 [信鸽多通道整合] 信鸽提供了根据不同的使用场景，智能选择推送通道的方式。会根据设备类型和需求的不同选择最合适的推送通道进行消息下发，保障最有效的触达 3.4.信鸽服务形态 [信鸽管理台] 信鸽提供的可视化推送管理界面，具备推送发送，历史查询，数据分析，开发调试等功能。在信鸽官网登入后即可进行使用。 [Rest API] 信鸽提供的后台API，包含推送消息，管理设备映射关系，数据查询等功能。方便您更好的进行定制化推送，并且和您现有的业务逻辑进行兼容。详情请阅读信鸽后台REST_API [移动端SDK] 信鸽提供了 iOS&Android 两个平台的推送SDK，SDK主要完成推送消息展现，数据统计的功能。此外SDK侧也提供了一系列的API接口，帮助您实现精准推送的业务逻辑。详情请看Android 终端 SDK_API ，iOS 终端 SDK_API 推送流程 [Push_Token] Push_Token是由信鸽生成的，对一个设备的标识（下文简称Token），用于对设备进行推送，是推送的最小单位。 [设备推送注册] 设备的推送注册，表示着设备和信鸽服务器成功的建立了长连接。设备将会和服务器进行通信 [长连接] 长连接是信鸽 Android SDK 维持的和信鸽后台的持续连接，在连接有效时能够将推送消息进行下发和展示。当长连接无法建立时，推送消息会被存储在信鸽后台，等待连接成功后下发 [账号] 在精准推送中会用到的概念，其他的推送系统中也称作别名/Alias。账号可以在终端SDK & 信鸽后台进行设置和管理。在完成绑定之后就可以使用账号来作为推送目标来进行消息推送了 [标签] 同样是精准推送中会用到的概念，开发者可以调用信鸽SDK & 后台API，为设备绑定一个/多个标签。在完成绑定之后，就可以针对标签来进行推送了，方便进行更精细化的运营 "},"android_access.html":{"url":"android_access.html","title":"Android接入","keywords":"","body":"Android接入 在Android接入部分，为开发者提供了快速接入指南、完整接入指南以及3.1版本升级指南。如果开发者想快速实现推送功能集成，可参考快速接入指南；如果想集成多场景推送功能，请参考完整接入指南 Android SDK API Android SDK 3.* 升级指南 Android SDK 集成指南 "},"android_access/xg_push_introduction.html":{"url":"android_access/xg_push_introduction.html","title":"Android 推送服务介绍","keywords":"","body":"XG推送服务介绍 信鸽（XG Push）是一款专业的移动 App 推送平台，支持百亿级的通知/消息推送，秒级触达移动用户，现已全面支持 Android 和 iOS 两大主流平台,开发者可以方便地通过嵌入 SDK，通过 API 调用或者Web端可视化操作，实现对特定用户推送，大幅提升用户活跃度，有效唤醒沉睡用户，并实时查看推送效果 信鸽推送流程原理介绍 简要说明Andoid客户端实现推送流程的步骤（不含厂商通道版本）： 客户端 App 启动的时候会启动一个信鸽主 Service, 信鸽主 Service 全局唯一，一台设备共享一个信鸽主 Service 信鸽主 Service 在接入信鸽的应用中随机启动一个备份的 Service, 2 个Service相互拉活，互为备份 信鸽主 Service 建立一个信鸽服务器的 Socket 长连接，并通过心跳等机制维持长连接一直存在 客户端主 Service 通过 Socket 长连接请求向信鸽服务器请求 Token 信鸽服务器通过 Socket 长连接推送消息到客户端主 Service 主 Service 把 Push 消息转发到对应的客户端 APP 上 简要说明Andoid客户端实现推送流程的步骤（含厂商通道版本）： 发送注册请求到第三方厂商服务请求Token 保存第三方 Token 并同步到信鸽服务器 第三方 Token 和 信鸽 Token 建立映射关系并保存 信鸽服务器根据 Token 关系调用第三方推送的 API 推送消息到第三方服务器 第三方服务器推送消息到客户端 APP 主要功能说明 Andoid SDK 是信鸽推送服务为客户端实现消息推送⽽而提供给开发者的接⼝主要负责完成： 提供通知和消息二种推送形式，方便用户使用 账号、标签与设备的绑定接⼝口，以便便开发者实现特定群组的消息推送，丰富推送⽅方式； 点击量量上报，统计消息被⽤用户点击的次数； 提供通知和消息二种推送形式，方便用户使用 提供多厂商通道集成功能，方便用户集成多厂商推送 "},"android_access/jcenter.html":{"url":"android_access/jcenter.html","title":"Android SDK 集成指南","keywords":"","body":"Android SDK 集成指南 通过AndroidStudio自动集成 导入依赖 AndroidStudio 上可以使用 jcenter 远程仓库自动接入，不需要在项目中导入jar包和so文件； 在 AndroidManifest.xml 中不需要配置信鸽相关的内容，jcenter 会自动导入。 导入依赖过后修改应用配置，书写注册代码就能够实现信鸽快速接入。 对应的依赖版本号均是官网上最新的版本。 用户自定义的recevier.依然需要在Androidmanifest.xml配置相关节点。 在app build.gradle文件下配置 以下内容 android { ...... defaultConfig { //信鸽官网上注册的包名.注意application ID 和当前的应用包名以及 信鸽官网上注册应用的包名必须一致。 applicationId \"你的包名\" ...... ndk { //根据需要 自行选择添加的对应cpu类型的.so库。 abiFilters 'armeabi', 'armeabi-v7a', 'arm64-v8a' // 还可以添加 'x86', 'x86_64', 'mips', 'mips64' } manifestPlaceholders = [ XG_ACCESS_ID:\"注册应用的accessid\", XG_ACCESS_KEY : \"注册应用的accesskey\", ] ...... } ...... } dependencies { ...... //完整的信鸽依赖三个都必须有，如果发生依赖冲突请根据对应的依赖版本号选择高版本的依赖。（使用jcenter自动接入请确认libs 中没有信鸽的相关jar包） //信鸽3.2.3 release版本 //完整的信鸽依赖三个都必须有，如果发生依赖冲突请根据对应的依赖版本号选择高版本的依赖。（使用jcenter自动接入请 确认libs 中没有信鸽的相关jar包） //信鸽3.2.4 beta版本 //compile 'com.tencent.xinge:xinge:3.2.4-beta' //信鸽jar compile 'com.tencent.xinge:xinge:3.2.3-release' //wup包 compile 'com.tencent.wup:wup:1.0.0.E-release' //mid包 compile 'com.tencent.mid:mid:4.0.6-release' } 注意: 如果在添加以上 abiFilter 配置之后 Android Studio 出现以下提示： NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. 则在 Project 根目录的 gradle.properties 文件中添加： android.useDeprecatedNdk=true 如需监听消息请参考XGBaseReceiver接口或者是 demo 的 MessageReceiver 类。自行继承XGBaseReceiver并且在配置文件中配置如下内容： 手动配置来进行集成 注册并下载SDK 前往信鸽管理台 xg.qq.com，使用QQ号码登陆，进入应用注册页，填写“应用名称”和“应用包名”（必须要跟APP一致），选择“操作系统”和“分类”，最后点击“创建应用”。 应用创建成功后，点击“应用配置”即可看到 APP 专属的 AccessId 和 AccessKey 等信息。 注册完成后，请下载最新版本的 Android SDK 到本地，并解压。 工程配置 将SDK导入到工程的步骤为： （1）创建或打开Android工程（关于如何创建Android工程，请参照开发环境的章节）。 （2）将信鸽 SDK目录下的libs目录所有文件拷贝到工程的libs（或lib）目录下。 （3）选中libs（或lib）目录下的信鸽jar包，右键菜单中选择Build Path， 选择Add to Build Path将SDK添加到工程的引用目录中。 （4）.so文件是信鸽必须的组件，支持armeabi、armeabi-v7a、misp和x86平台，请根据自己当前.so支持的平台添加 a）如果你的项目中没有使用其它.so，建议复制四个平台目录到自己工程中； b）如果已有.so文件，只需要复制信鸽对应目录下的文件； c）若是MSDK接入的游戏，通常只需要armeabi目录下的.so； d）若当前工程已经有armeabi，那么只需要添加信鸽的armeabi下的.so，其它目录无需添加。其它情况类似，只添 加当前 平台存在的平台即可。 e）若在Androidstudio中导入so文件出错（错误10004.SOERROR），在main文件目录下 添加jniLibs命名的文件 夹将所有的架构文件复制进去也就是SDK文档中的Other-Platform-SO下的所有文件夹。如图： （5）打开Androidmanifest.xml，添加以下配置（建议参考下载包的Demo修改），其中YOUR_ACCESS_ID和YOUR_ACCESS_KEY替换为APP对应的accessId和accessKey,请确保按照要求配置，否则可能导致服务不能正常使用。 注册以及部分日志输出。 1.根据手动接入或者自动接入，配置好信鸽过后，获取信鸽注册日志（接入过程中建议调用有回调的注册接口，开启信鸽的debug日志输出。AndroidStudio 建议采用jcenter自动接入，无需在配置文件中配置信鸽各个节点，全部由依赖导入）。 开启debug日志数据 XGPushConfig.enableDebug(this,true); token注册 XGPushManager.registerPush(this, new XGIOperateCallback() { @Override public void onSuccess(Object data, int flag) { //token在设备卸载重装的时候有可能会变 Log.d(\"TPush\", \"注册成功，设备token为：\" + data); } @Override public void onFail(Object data, int errCode, String msg) { Log.d(\"TPush\", \"注册失败，错误码：\" + errCode + \",错误信息：\" + msg); } }) 过滤\"TPush\"注册成功的日志如下： 10-09 20:08:46.922 24290-24303/com.qq.xgdemo I/XINGE: [TPush] get RegisterEntity:RegisterEntity [accessId=2100250470, accessKey=null, token=5874b7465d9eead746bd9374559e010b0d1c0bc4, packageName=com.qq.xgdemo, state=0, timestamp=1507550766, xgSDKVersion=3.11, appVersion=1.0] 10-09 20:08:47.232 24290-24360/com.qq.xgdemo D/TPush: 注册成功，设备token为：5874b7465d9eead746bd9374559e010b0d1c0bc4 设置账号 //注意在3.2.2 版本信鸽对账号绑定和解绑接口进行了升级具体详情请参考API文档。 XGPushManager.bindAccount(getApplicationContext(), \"XINGE\"); 过滤“TPush”账号注册成功的日志如下： //如推送返回48账号无效，请确认账号接口调用成功 10-11 15:55:57.810 29299-29299/com.qq.xgdemo D/TPushReceiver: TPushRegisterMessage [accessId=2100250470, deviceId=853861b6bba92fb1b63a8296a54f439e, account=XINGE, ticket=0, ticketType=0, token=3f13f775079df2d54e1f82475a28bccd3bfef8c1]注册成功 设置标签 XGPushManager.setTag(this,\"XINGE\"); 设置标签成功的日志： 10-09 20:11:42.558 27348-27348/com.qq.xgdemo I/XINGE: [XGPushManager] Action -> setTag with tag = XINGE 收到消息日志 10-16 19:50:01.065 5969-6098/com.qq.xgdemo D/XINGE: [i] Action -> handleRemotePushMessage 10-16 19:50:01.065 5969-6098/com.qq.xgdemo I/XINGE: [i] >> msg from service, @msgId=1 @accId=2100250470 @timeUs=1508154601660412 @recTime=1508154601076 @msg.date= @msg.busiMsgId=0 @msg.timestamp=1508154601 @msg.type=1 @msg.multiPkg=0 @msg.serverTime=1508154601000 @msg.ttl=259200 @expire_time=1508154860200076 @currentTimeMillis=1508154601076 10-16 19:50:01.095 5969-6098/com.qq.xgdemo D/XINGE: [m] Action -> handlerPushMessage 10-16 19:50:01.105 5969-6098/com.qq.xgdemo I/XINGE: [m] Receiver msg from server :PushMessageManager [msgId=1, accessId=2100250470, busiMsgId=0, content={\"n_id\":0,\"title\":\"XGDemo\",\"style_id\":1,\"icon_type\":0,\"builder_id\":1,\"vibrate\":0,\"ring_raw\":\"\",\"content\":\"token 推送\",\"lights\":1,\"clearable\":1,\"action\":{\"aty_attr\":{\"pf\":0,\"if\":0},\"action_type\":1,\"activity\":\"\"},\"small_icon\":\"\",\"ring\":1,\"icon_res\":\"\",\"custom_content\":{}}, timestamps=1508154601, type=1, intent=Intent { act=com.tencent.android.tpush.action.INTERNAL_PUSH_MESSAGE cat=[android.intent.category.BROWSABLE] pkg=com.qq.xgdemo (has extras) }, messageHolder=BaseMessageHolder [msgJson={\"n_id\":0,\"title\":\"XGDemo\",\"style_id\":1,\"icon_type\":0,\"builder_id\":1,\"vibrate\":0,\"ring_raw\":\"\",\"content\":\"token 推送\",\"lights\":1,\"clearable\":1,\"action\":{\"aty_attr\":{\"pf\":0,\"if\":0},\"action_type\":1,\"activity\":\"\"},\"small_icon\":\"\",\"ring\":1,\"icon_res\":\"\",\"custom_content\":{}}, msgJsonStr={\"n_id\":0,\"title\":\"XGDemo\",\"style_id\":1,\"icon_type\":0,\"builder_id\":1,\"vibrate\":0,\"ring_raw\":\"\",\"content\":\"token 推送\",\"lights\":1,\"clearable\":1,\"action\":{\"aty_attr\":{\"pf\":0,\"if\":0},\"action_type\":1,\"activity\":\"\"},\"small_icon\":\"\",\"ring\":1,\"icon_res\":\"\",\"custom_content\":{}}, title=XGDemo, content=token 推送, customContent=null, acceptTime=null]] 10-16 19:50:01.105 5969-6098/com.qq.xgdemo V/XINGE: [XGPushManager] Action -> msgAck(com.qq.xgdemo,1) 10-16 19:50:01.115 5969-6098/com.qq.xgdemo I/XINGE: [TPush] title encry obj:{\"cipher\":\"YZXM+CuPhqaBn4eK0SE9ApWieHznugNT2uKo0OaXtlDDHLJiY7NlvSL2ZnlSb8E7yd7E7i9JU3g0PlFyYNLjokNp1buJuPoMYEHaJ0s6vmUMY+cq0Sv782XHxNzekV4a9mRcJ5xsOccIjH1VoskUmikfZJo3XLhZveWNYGPaoto=\"} 10-16 19:50:01.125 5969-6098/com.qq.xgdemo E/XINGE: [MessageInfoManager] delOldShowedCacheMessage Error! toDelTime: 1507981801138 10-16 19:50:01.145 5969-6098/com.qq.xgdemo I/XINGE: [MessageHelper] Action -> showNotification {\"n_id\":0,\"title\":\"XGDemo\",\"style_id\":1,\"icon_type\":0,\"builder_id\":1,\"vibrate\":0,\"ring_raw\":\"\",\"content\":\"token 推送\",\"lights\":1,\"clearable\":1,\"action\":{\"aty_attr\":{\"pf\":0,\"if\":0},\"action_type\":1,\"activity\":\"\"},\"small_icon\":\"\",\"ring\":1,\"icon_res\":\"\",\"custom_content\":{}} 代码混淆 如果您的项目中使用proguard等工具做了代码混淆，请保留以下选项，否则将导致信鸽服务不可用。 -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep class com.tencent.android.tpush.** {* ;} -keep class com.tencent.mid.** {* ;} -keep class com.qq.taf.jce.** {*;} "},"android_access/upgrade_guide.html":{"url":"android_access/upgrade_guide.html","title":"Android SDK 3.* 版本升级指南","keywords":"","body":"信鸽Android SDK 3.* 版本升级指南 【必须】提取SDK文档中的最新jar包替换当前信鸽SDK版本。 【必须】根据所需平台，提取libtpnsSecurity.so和libxguardian.so替换老版本 【必须】添加XGPushActivity页面配置和设置用户自定义的MessageReceiver的android:exported 为\"false\" 如下所示 4.【必须】检查是否配置 com.tencent.android.tpush.service.XGPushServiceV3 com.tencent.android.tpush.rpc.XGRemoteService 若无配置则功能不可用 5.【必须】检查是否配置 com.tencent.android.tpush.XGPushProvider com.tencent.android.tpush.SettingsContentProvider com.tencent.mid.api.MidProvider 若无配置则功能不可用 【可选】整理权限 "},"android_access/android_api.html":{"url":"android_access/android_api.html","title":"Android SDK API","keywords":"","body":"API接口 接口概览 所有API接口的包名路径前缀都是：com.tencent.android.tpush，其中有以下个重要的对外提供接口的类，如下： 类名 说明 XGPushManager Push服务推送 XGPushConfig Push服务配置项接口 XGPushBaseReceiver 接收消息和结果反馈的receiver，需要开发者自己在AndroidManifest.xml静态注册 XGPushManager功能类 XGPushManager提供信鸽服务的对外API列表，方法默认为public static类型。 原型 功能 void registerPush(Context context) 启动并注册（无注册回调） void registerPush (Context context, final XGIOperateCallback callback) 启动并注册（有注册回调） void registerPush( Context context, String account, XGIOperateCallback callback ) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2不包括3.2.2之前的版本使用，有注册回调） void bindAccount( Context context, String account, XGIOperateCallback callback ) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口会覆盖设备之前绑定过的账号，仅当前注册的账号生效） void bindAccount( Context context, final String account ) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口会覆盖设备之前绑定过的账号，仅当前注册的账号生效，无注册回调） void appendAccount( Context context, String account, XGIOperateCallback callback ) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口保留之前的账号，只做增加操作，一个token下最多只能有3个账号超过限制会自动顶掉之前绑定的账号，有注册回调） void appendAccount( Context context, final String account ) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口保留之前的账号，只做增加操作，一个token下最多只能有3个账号超过限制会自动顶掉之前绑定的账号，无注册回调） void delAccount( Context context, final String account, XGIOperateCallback callback ) 解绑指定账号（3.2.2以及3.2.2之后的版本使用，有注册回调） void delAccount( Context context, final String account ) 解绑指定账号（3.2.2以及3.2.2之后的版本使用，无注册回调） void registerPush( Context context, String account, String ticket, int ticketType, String qua, final XGIOperateCallback callback ) 同上，仅供带登陆态的业务使用 void unregisterPush(Context context) 反注册，建议在不需要接收推送的时候调用 void setTag( Context context, String tagName ) 设置标签 void deleteTag( Context context, String tagName ) 删除标签 XGPushClickedResult onActivityStarted(Activity activity) Activity被打开的效果统计；获取下发的自定义key-value void onActivityStoped( Activity activity ) Activity被打开的效果统计 void setPushNotificationBuilder( Context context, int notificationBulderId, XGPushNotificationBuilder notifiBuilder ) 自定义本地通知样式 long addLocalNotification( Context context, XGLocalMessage msg ) 本地通知 boolean isNotificationOpened( Context context ) 检测通知栏是否关闭 XGPushConfig配置类 XGPushConfig提供信鸽服务的对外配置API列表，方法默认为public static类型，对于本类提供的set和enable方法，要在XGPushManager接口前调用才能及时生效。 原型 功能 void enableDebug( Context context, boolean debugMode ) 是否开启debug模式，即输出logcat日志重要：为保证数据的安全性，发布前必须设置为false） boolean setAccessId(Context context,long accessId) 配置accessId boolean setAccessKey(Context context,String accessKey) 配置accessKey String getToken(Context context) 获取设备的token，只有注册成功才能获取到正常的结果 void setReportNotificationStatusEnable(final Context context,final boolean debugMode) 设置上报通知栏是否关闭 默认打开 void setReportApplistEnable(final Context context,final boolean debugMode) 设置上报APP 列表，用于智能推送 默认打开 void enableOtherPush(Context context, boolean flag) 设置支持第三方厂商推送 void setMiPushAppId(Context context, String appid) 设置小米推送APPID void setMiPushAppKey(Context context, String appkey) 设置小米推送APPKEY void setMzPushAppId(Context context, String appid) 设置魅族推送APPID void setMzPushAppKey(Context context, String appkey) 设置魅族推送APPKEY void setHuaweiDebug(boolean isHuaweiDebug) 华为手机的写日志定位问题 XGPushBaseReceiver广播类 XGPushBaseReceiver类提供透传消息的接收和操作结果的反馈，需要开发者继承本类，并重载相关的方法； 同时，还需要在AndroidManifest.xml静态注册（注意：如果是在代码动态注册，只有当前APP运行时才能收到消息）。 原型 功能 void onTextMessage(Context context,XGPushTextMessage message) 应用内消息的回调 void onRegisterResult(Context context,int errorCode,XGPushRegisterResult registerMessage) 注册回调 void onUnregisterResult(Context context, int errorCode) 反注册回调 void onSetTagResult(Context context,int errorCode,String tagName) 设置标签回调 void onDeleteTagResult(Context context, int errorCode,String tagName) 删除标签回调 void onNotifactionShowedResult(Context context, XGPushShowedResult notifiShowedRlt) 通知被展示触发的回调，可以在此保存APP收到的通知 void onNotifactionClickedResult(Context context, XGPushClickedResult message) 通知被点击触发的回调 启动与注册 APP只有在完成信鸽的启动与注册后才可以信鸽SDK提供push服务，在这之前请确保配置AccessId和AccessKey。 新版的SDK已经将启动信鸽和APP注册统一集成在注册接口中，即只需调用注册接口便默认完成启动和注册操作。 注册成功后，会返回设备token，token用于标识设备唯一性，同时也是信鸽维持与后台连接的唯一身份标识。关于如何获取token请参考“获取token”章节。 注册接口通常提供简版和带callback版本的接口，请根据业务需要决定选择接口。 绑定设备注册 普通注册只注册当前设备，后台能够针对不同的设备token发送推送消息，有2个版本的API接口。 注意：这种注册方式，不支持推送帐号。 （1）原型 public static void registerPush(Context context) （2）参数 context：当前应用上下文对象，不能为null （3）示例 XGPushManager.registerPush(this); 另外，为方便用户获取注册是否成功的状态，提供带callback的版本。 （1）原型 public static void registerPush(Context context, final XGIOperateCallback callback) （2）参数 context：当前应用上下文对象，不能为null callback：callback调用，主要包括操作成功和失败的回调，不能为null （3）示例 XGPushManager.registerPush(this, new XGIOperateCallback() { @Override public void onSuccess(Object data, int flag) { Log.d(\"TPush\", \"注册成功，设备token为：\" + data); } @Override public void onFail(Object data, int errCode, String msg) { Log.d(\"TPush\", \"注册失败，错误码：\" + errCode + \",错误信息：\" + msg); } }) 绑定账号注册 绑定账号注册指的是，在绑定设备注册的基础上，使用指定的账号（一个账号不能在多个设备登陆）注册APP，这样可以通过后台向指定的账号发送推送消息，有2个版本的API接口。 注意：这里的帐号可以是邮箱、QQ号、手机号、用户名等任意类别的业务帐号。 （1）原型 public static void registerPush(Context context, String account) （2）参数 context：当前应用上下文对象，不能为null account：绑定的账号，绑定后可以针对账号发送推送消息，account不能为单个字符如“2”，“a”。 如果要按别名推送，那就需要开发者在调用注册接口时把别名设置在注册请求里面的account字段，一台设备只允许有一个帐号别名。 （3）示例 XGPushManager.registerPush(this, \"UserAccount\") 另外，为方便用户获取注册是否成功的状态，提供带callback的版本。 （1）原型 public static void registerPush(Context context, String account, final XGIOperateCallback callback) （2）参数 context：当前应用上下文对象，不能为null account：绑定的账号，绑定后可以针对账号发送推送消息。 如果要按别名推送，那就需要开发者在调用注册接口时把别名设置在注册请求里面的account字段，一台设备只允许有一个别名，多个设备登录同一个账号最后一个绑定的设备有效，不能为null callback：callback调用，主要包括操作成功和失败的回调，不能为null 注：在信鸽3.2.2beta版本以后账号绑定需要调用全新的接口 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2不包括3.2.2之前的版本使用，有注册回调 void registerPush(Context context, String account, XGIOperateCallback callback) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口会覆盖设备之前绑定过的账号，仅当前注册的账号生效） void bindAccount(Context context, String account, XGIOperateCallback callback) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口会覆盖设备之前绑定过的账号，仅当前注册的账号生效，无注册回调） void bindAccount(Context context, final String account) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口保留之前的账号，只做增加操作，一个token下最多只能有3个账号超过限制会自动顶掉之前绑定的账号，有注册回调） void appendAccount(Context context, String account, XGIOperateCallback callback) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口保留之前的账号，只做增加操作，一个token下最多只能有3个账号超过限制会自动顶掉之前绑定的账号，无注册回调） void appendAccount(Context context, final String account) （3）示例 XGPushManager.registerPush(this, \"UserAccount\", new XGIOperateCallback() { @Override public void onSuccess(Object data, int flag) { Log.d(\"TPush\", \"注册成功，设备token为：\" + data); } @Override public void onFail(Object data, int errCode, String msg) { Log.d(\"TPush\", \"注册失败，错误码：\" + errCode + \",错误信息：\" + msg); } }); 账号解绑 若APP调用registerPush(context, account)等绑定account账号，需要解绑（如用户退出），可以调用以下方法。 调用 registerPush(context, \"*\")或registerPush(context, \"*\", xGIOperateCallback ) 即设置account=\"*\"即为解除之前的账号绑定 在信鸽3.2.2版本以后解绑账号需要调用全新的接口： //解绑指定账号（3.2.2以及3.2.2之后的版本使用，有注册回调） void delAccount(Context context, final String account, XGIOperateCallback callback) //解绑指定账号（3.2.2以及3.2.2之后的版本使用，无注册回调） void delAccount(Context context, final String account ） 注意 账号解绑只是解除token与APP账号的关联，若使用全量/标签/token推送仍然能收到通知/消息。 带登陆态的注册 考虑到用户的登陆态问题，比如手机QQ或QZone业务场景，我们提供了带登陆态的注册接口，方便适用该类业务的使用。 （1）原型 public static void registerPush(Context context, String account, String ticket, int ticketType, String qua, final XGIOperateCallback callback) ***（2）参数 *** context：当前应用上下文对象，不能为null callback：操作回调，主要包括操作成功和失败的回调，不能为null account：绑定的账号，绑定后可以针对账号发送推送消息。 如果要按别名推送，那就需要开发者在调用注册接口时把别名设置在注册请求里面的account字段，一台设备只允许有一个别名，但一个别名下可以有15台设备，不能为null ticket：登陆态票据，不能为null ticketType：票据类型 qua：QZone专用字段，不需要时可填null ***（3）示例** ```java XGPushManager.registerPush(this, \"UserAccount\", \"ticket\", 1, null, new XGIOperateCallback() { @Override public void onSuccess(Object data, int flag) { Log.d(\"TPush\", \"注册成功，设备token为：\" + data); } @Override public void onFail(Object data, int errCode, String msg) { Log.d(\"TPush\", \"注册失败，错误码：\" + errCode + \",错误信息：\" + msg); } }); 获取注册结果 有2种途径可以获取注册是否成功。 （1） 使用callback版本的注册接口 XGIOperateCallback类提供注册成功或失败的处理接口，请参考注册接口里面的示例。 XGIOperateCallback的定义： /** * 操作回调接口 */ public interface XGIOperateCallback { /** * 操作成功时的回调。 * @param data 操作成功的业务数据，如注册成功时的token信息等。 * @param flag 标记码 */ public void onSuccess(Object data, int flag); /** * 操作失败时的回调 * @param data 操作失败的业务数据 * @param errCode 错误码 * @param msg 错误信息 */ public void onFail(Object data, int errCode, String msg); } （2）重载XGPushBaseReceiver 可通过重载XGPushBaseReceiver的onRegisterResult方法获取。 （注意：重载的XGPushBaseReceiver需要配置在AndroidManifest.xml，请参考“消息配置”章节的相关内容） 示例 /** * 注册结果 * * @param context * APP上下文对象 * @param errorCode * 错误码，{@link XGPushBaseReceiver#SUCCESS}表示成功，其它表示失败 * @param registerMessage * 注册结果返回 */ 其中，XGPushRegisterResult提供的方法列表： 方法名 返回值 默认值 描述 getToken() String \"\" 设备的token，即设备唯一识别ID getAccessId() long 0 获取注册的accessId getAccount String \"\" 获取注册绑定的账号 getTicket() String \"\" 登陆态票据 getTicketType() short 0 票据类型 反注册 当用户已退出或APP被关闭，不再需要接收推送时，可以取消注册APP，即反注册。（注意一旦设备反注册，直到这个设备重新注册成功这个期间内，下发的消息该设备都无法收到) （1）原型 public static void unregisterPush(Context context) （2）参数 context： APP的上下文对象。 （3）示例 XGPushManager.unregisterPush(this); 反注册结果 可通过重载XGPushBaseReceiver的onUnregisterResult方法获取。 示例 /** * 反注册结果 * * @param context * APP上下文对象 * @param errorCode * 错误码，{@link XGPushBaseReceiver#SUCCESS}表示成功，其它表示失败 */ @Override public void onUnregisterResult(Context context, int errorCode) { } 注意 反注册操作切勿过于频繁，可能会造成后台同步延时。 切换帐号无需反注册，多次注册自动会以最后一次为准。 通知和消息 信鸽推送服务主要提供2种推送格式： “推送通知” 和 “透传消息命令”，二者存在一定的区别。 推送通知（展现在通知栏） 指的是在设备的通知栏展示的内容，由信鸽SDK完成所有的操作，APP可以监听通知被打开的行为，也就是说在前台下发的通知不需要APP做任何处理，默认会展示在通知栏。 成功注册信鸽服务后，通常不需要任何设置便可下发通知。 通常来说，结合自定义通知样式，常规的通知能够满足大部分业务需求，如果需要更灵活的方式请考虑使用消息。 应用内消息命令（消息不展示到通知栏） 指的是由信鸽下发给APP的内容，需要APP继承XGPushBaseReceiver接口实现并自主处理所有操作过程，也就是说，下发的消息默认是不会展示在通知栏的，信鸽只负责将消息从信鸽服务器下发到APP这个过程，不负责消息的处理逻辑，需要APP自己实现。具体可参考Demo中MessageReceiver。 消息指的是由开发者通过前台或后台脚本下发的文本消息，信鸽只负责将消息传递给APP，APP完全自主负责消息体的处理。 消息具有灵活性强和高度定制性特点，因此更适合APP自主处理个性化业务需求，比如下发APP配置信息、自定义处理消息的存储和展示等。 例如：某游戏需要针对不同情景（用户升级提示、版本更新提示、活动营销提示等）提供不同的通知，可以把这些情景以json格式封装在消息，下发到APP，然后APP根据这些场景提供不同的提示，满足个性化需求。 消息配置 若要接收消息，需要配置消息接收Receiver，即在AndroidManifest.xml配置以下信息，其中android:name的值需要修改为APP自己实现的Receiver。 获取应用内消息 开发者在前台下发消息，需要APP继承XGPushBaseReceiver重载onTextMessage方法接收，成功接收后，再根据特有业务场景进行处理。 同时，XGPushBaseReceiver还提供其它相关的接口，如通知被展示、被点击的结果反馈、注册/反注册结果反馈等，请参考“XGPushBaseReceiver”章节或demo中的MessageReceiver类。 请确保在AndroidManifest.xml已经注册过该receiver，即设YOUR_PACKAGE.XGPushBaseReceiver。 原型 public void onTextMessage(Context context, XGPushTextMessage message) 参数 context：应用当前上下文 message：接收到消息结构体，其中XGPushTextMessage的方法列表如下： 方法名 返回值 默认值 描述 etContent() String \"\" 消息正文内容，通常只需要下发本字段即可 getCustomContent() String \"\" 消息自定义key-value getTitle() String \"\" 消息标题（注意：从前台下发应用内消息字中的描述不属于标题 本地通知 本地通知由用户自定义设置，保存在本地。当应用打开，信鸽service 会根据网络心跳判断当前是否有通知5分钟一次 本地通知需要service开启才能弹出，可能存在5分钟左右延时。（当设置的时间小于当前设备时间通知弹出。） ```java //新建本地通知 XGLocalMessage local_msg = new XGLocalMessage(); //设置本地消息类型，1:通知，2:消息 local_msg.setType(1); // 设置消息标题 local_msg.setTitle(\"qq\"); //设置消息内容 local_msg.setContent(\"ww\"); //设置消息日期，格式为：20140502 local_msg.setDate(\"20140930\"); //设置消息触发的小时(24小时制)，例如：22代表晚上10点 local_msg.setHour(\"19\"); //获取消息触发的分钟，例如：05代表05分 local_msg.setMin(\"31\"); //设置消息样式，默认为0或不设置 local_msg.setBuilderId(0); //设置动作类型：1打开activity或app本身，2打开浏览器，3打开Intent ，4通过包名打开应用 local_msg.setAction_type(1); //设置拉起应用页面 local_msg.setActivity(\"com.qq.xgdemo.SettingActivity\"); // 设置URL local_msg.setUrl(\"http://www.baidu.com\"); // 设置Intent local_msg.setIntent(\"intent:10086#Intent;scheme=tel;action=android.intent.action.DIAL;S.key=value;end\"); // 是否覆盖原先build_id的保存设置。1覆盖，0不覆盖 local_msg.setStyle_id(1); // 设置音频资源 local_msg.setRing_raw(\"mm\"); // 设置key,value HashMap map = new HashMap(); map.put(\"key\", \"v1\"); map.put(\"key2\", \"v2\"); local_msg.setCustomContent(map); // 设置下载应用URL local_msg.setPackageDownloadUrl(\"http://softfile.3g.qq.com:8080/msoft/179/1105/10753/MobileQQ1.0(Android)_Build0198.apk\"); //添加通知到本地 XGPushManager.addLocalNotification(context,local_msg); ``` 自定义通知样式 用户可以根据自行需要设置通知样式，但由于目前定制ROM的限制，部分接口无法适配全部机型。 XGCustomPushNotificationBuilder build = new XGCustomPushNotificationBuilder(); build.setSound( RingtoneManager.getActualDefaultRingtoneUri( getApplicationContext(), RingtoneManager.TYPE_ALARM)) .setDefaults(Notification.DEFAULT_VIBRATE) // 振动 .setFlags(Notification.FLAG_NO_CLEAR); // 是否可清除 // 设置自定义通知layout,通知背景等可以在layout里设置 build.setLayoutId(R.layout.notification); // 设置自定义通知内容id build.setLayoutTextId(R.id.content); // 设置自定义通知标题id build.setLayoutTitleId(R.id.title); // 设置自定义通知图片资源 build.setLayoutIconDrawableId(R.drawable.logo); // 设置状态栏的通知小图标 build.setIcon(R.drawable.right); // 设置时间id build.setLayoutTimeId(R.id.time); // 若不设定以上自定义layout，又想简单指定通知栏图片资源 build.setNotificationLargeIcon(R.drawable.ic_action_search); // 客户端保存build_id XGPushManager.setPushNotificationBuilder(this, build_id, build); 获取设备Token Token是信鸽保持与后台长连接的唯一身份标识，是APP接收消息的唯一ID，只有设备注册成功后才能获取Token，可以有以下方法获。（信鸽的token在应用卸载重新安装的时候有可能会变。） （1）通过带callback的注册接口获取 带XGIOperateCallback的注册接口的onSuccess(Object data, int flag)方法中，参数data便是token，具体可参考注册接口的相关示例。 （2）重载XGPushBaseReceiver 重载XGPushBaseReceiver的onRegisterResult (Context context, int errorCode, XGPushRegisterResult registerMessage)方法，通过参数registerMessage提供的getToken接口获取，具体可参考“获取注册结果”章节。 （3） XGPushConfig.getToken(context) 当设备一旦注册成功后，便会将token存储在本地，之后可通过XGPushConfig.getToken(context)接口获取。 获取通知 通知的下发和展示完全是由信鸽SDK控制的，但有的开发者需要在本地存储被展示过的通知内容，可以通过重载XGPushBaseReceiver的onNotificationShowedResult(Context, XGPushShowedResult)方法实现。其中，XGPushShowedResult对象提供读取通知内容的接口。 原型 public abstract void onNotificationShowedResult(Context context,XGPushShowedResult notifiShowedRlt); 参数 context：当前应用上下文 notifiShowedRlt： 被展示的通知对象 获取消息点击结果 【2.30及以上版本】通知效果监听和自定义key-value 使用信鸽SDK内置的activity展示页面，默认已经统计通知/消息的抵达量、通知的点击和清除动作。但如果开发者要监听这些事件，需要按照以下方法嵌入代码。 注意：如果需要统计由信鸽推送引起的打开APP操作或获取下发的自定义key-value，需要开发者在所有（或被打开）的Activity的onResume()调用以下方法。 （1）原型 public abstract void onNotificationShowedResult(Context context,XGPushShowedResult notifiShowedRlt); （2）参数 activity：被打开activity上下文 （3）返回值 XGPushClickedResult：通知被打开的对象，如果该activity是由信鸽的通知引起打开动作的，返回XGPushClickedResult，否则返回null。 XGPushClickedResult类方法列表： 方法名 返回值 默认值 描述 getMsgId() long 0 消息id getTitle() String \"\" 通知标题 getContent() String \"\" 通知正文内容 getActivityName() String \"\" 被打开的页面名称 getCustomContent() String \"\" 自定义key-value，json字符串同时，在Activity的onPause()调用以下方法 （1）原型 public static void onActivityStoped(Activity activity) （2）参数 activity：当前activity上下文 （3）示例 @Override protected void onPause() { super.onPause(); XGPushClickedResult clickedResult = XGPushManager.onActivityStarted(this); String customContent= clickedResult.getCustomContent(); } 标签 预置标签 目前信鸽提供三类预置标签： 地理位置（省一级） 应用版本号 流失用户（3天or7天） 预置标签会在SDK内部自动上报。 设置标签 开发者可以针对不同的用户设置标签，然后在前台根据标签名群发通知。 一个应用最多有10000个tag， 每个token在一个应用下最多100个tag， tag中不准包含空格。 函数原型 public static void setTag(Context context, String tagName) 参数 context：Context对象 tagName：待设置的标签名称，不能为null或空。 处理结果 可通过重载XGPushBaseReceiver的onSetTagResult方法获取。 示例 XGPushManager.setTag(this, \"male\"); 删除标签 开发者删除用户标签数据。 函数原型 public static void deleteTag(Context context, String tagName) 参数 context：Context对象 tagName：待设置的标签名称，不能为null或空 处理结果 可通过重载XGPushBaseReceiver的onDeleteTagResult方法获取。 示例 XGPushManager.deleteTag (this, \"male\"); 配置接口 所有的配置相关接口在XGPushConfig类中，为了使配置及时生效，开发者需要保证配置接口在启动或注册信鸽之前被调用。 debug模式 （重要：为保证数据的安全性，请在发布时确保已关闭debug模式！！） （1）函数原型 public static void enableDebug(Context context, boolean debugMode) （2）参数 context:APP上下文对象 debugMode：默认为false。如果要开启debug日志，设为true 获取token token（又称MID：Mobile ID）是一个设备的身份识别ID，由服务器根据设备属性随机产生并下发到本地，同一台设备下所有使用信鸽或MTA（腾讯移动分析）的APP获取的token都是相同的。 使用token的一个好处是可以消除山寨机设备ID重复带来的统计影响，提高精准度。 如果您恰好正在使用最新版本的MTA，通过MTA的StatConfig.getMid()接口获取到的mid跟本接口是一样的。 注意：第一次注册会产生token，之后一直存在手机里，不管以后注销注册操作，该token一直存在。在3.0及其以上版本，token 在卸载重装等情况下 可能会改变。 （1）函数原型 public static String getToken(Context context) （2）参数 context：APP上下文对象 （3）返回值 成功时返回正常的token；失败时返回null或”0” 设置AccessID 如果已在AndroidManifest.xml配置过，不需要再次调用；如果2者都存在，则以本接口为准。 （1）函数原型 public static boolean setAccessId(Context context, long accessId) （2）参数 Context对象 accessId：前台注册得到的accessId （3）返回值 true：成功 false：失败 注意：通过本接口设置的accessId会同时存储在文件中 设置AccessKey 如果已在AndroidManifest.xml配置过，不需要再次调用；如果2者都存在，则以本接口为准。 （1）函数原型 public static boolean setAccessId(Context context, String accessKey) （2）参数 Context对象 accessId：前台注册得到的accesskey （3）返回值 true：成功 false：失败 注意：通过本接口设置的accessId会同时存储在文件中 "},"android_access/huawei_push.html":{"url":"android_access/huawei_push.html","title":"华为推送通道集成指南","keywords":"","body":"华为推送通道集成指南 华为推送通道是由华为官方提供的系统级推送通道。在华为手机上，推送消息能够通过华为的系统通道抵达终端，并且无需打开应用就能够收到推送。使用此功能必须先集成信鸽3.2.1-beta以上版本。 注意事项： 华为推送只有在签名发布包环境下才可以收到推送消息 华为手机中的移动推送服务，必须升级到 2.5.3 以上版本，华为通道会注册失败（依旧走信鸽通道）。 获取华为推送密钥 1.访问 华为开放平台 2.注册/登录开发者账号。（如果您是新注册账号，需进行实名认证） 3.在华为推送平台中新建应用。注意：应用包名需跟您在信鸽填写的包名保持一致 4.获取应用相关的信息，并且将这些信息复制，填入信鸽管理台的应用配置-厂商&海外通栏目中， 这些信息是AppID，AppSecret 如下图所示： 配置SHA256证书指纹 [配置示例] 获取SHA256证书指纹方法请参照 华为推送接入文档 集成指南 AndroidStudio集成方法 在app模块下的build.gradle文件内先配置好信鸽所需要的配置之后再增加以下的华为节点： 1.配置华为APPID manifestPlaceholders = [ HW_APPID: \"华为的APPID\" ] 2.导入华为推送相关依赖 以下两个版本请根据需要选择其中之一 //在集成信鸽的基础上新增华为push的jar包 compile 'com.tencent.xinge:xghw:2.5.2.300-release' /* 华为 3.2.4-beta版 * 注意：若华为通道使用此版本,则信鸽sdk版本也需要同时使用v3.2.4-beta */ compile 'com.tencent.xinge:xghw:3.2.4-beta' 3.配置 华为消息receiver. 注： 如果使用xghw:3.2.4-beta版本则不需要此步骤，只需要前两步即可 Eclipes集成方法 1.导入华为推送相关jar包 将HMSSdkBase_*.jar，HMSSdkPush_*.jar放在libs文件夹里。 2.在 Androidmanifest.xml 文件中新增如下配置： 3.2.配置 华为消息receiver. 华为消息receiver 1.自定义类，继承com.huawei.hms.support.api.push.PushReceiver， 并且在Androidmanifest.xml中配置相关的节点。 示例代码： public class MyReceiver extends PushReceiver { @Override public void onEvent(Context context, Event arg1, Bundle arg2) { super.onEvent(context, arg1, arg2); showToast(\"onEvent\" + arg1 + \" Bundle \" + arg2 , context); } @Override public boolean onPushMsg(Context context, byte[] arg1, Bundle arg2) { showToast(\"onPushMsg\" + new String(arg1) + \" Bundle \" + arg2 , context); return super.onPushMsg(context, arg1, arg2); } @Override public void onPushMsg(Context context, byte[] arg1, String arg2) { showToast(\"onPushMsg\" + new String(arg1) + \" arg2 \" + arg2 , context); super.onPushMsg(context, arg1, arg2); } @Override public void onPushState(Context context, boolean arg1) { showToast(\"onPushState\" + arg1, context); super.onPushState(context, arg1); } @Override public void onToken(Context context, String arg1, Bundle arg2) { super.onToken(context, arg1, arg2); showToast(\" onToken\" + arg1 + \"bundke \" + arg2, context); } @Override public void onToken(Context context, String arg1) { super.onToken(context, arg1); showToast(\" onToken\" + arg1 , context); } public void showToast(final String toast, final Context context) { new Thread(new Runnable() { @Override public void run() { Looper.prepare(); Toast.makeText(context, toast, Toast.LENGTH_SHORT).show(); Looper.loop(); } }).start(); } private void writeToFile(String conrent) { String SDPATH = Environment.getExternalStorageDirectory() + \"/huawei.txt\"; try { FileWriter fileWriter = new FileWriter(SDPATH, true); fileWriter.write(conrent+\"\\r\\n\"); fileWriter.flush(); fileWriter.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 在 AndroidManifest.xml 增加自定义 Receiver 配置如下： 启动华为推送以及注册日志 在调用信鸽（XGPushManager.registerPush）之前开启第三方推送接口： //打开第三方推送 XGPushConfig.enableOtherPush(getApplicationContext(), true); 注册成功的日志如下： 01-15 16:40:41.116 17916-17934/? I/XINGE: [XGOtherPush] other push token is : 0865551032618726300001294600CN01 other push type: huawei 01-15 16:40:41.122 15730-15846/? I/XINGE: [a] binder other push token with accid = 2100274337 token = 17c32948df0346d5837d4748192e9d2f14c81e08 otherPushType = huawei otherPushToken = 0865551032618726300001294600CN01 如果日志中出现： otherPushType = huawei otherPushToken = null 请在注册代码之前调用： XGPushConfig.setHuaweiDebug(true); 并手动确认给应用存储权限，然后查看SD卡目录下的 huawei.txt 文件内输出的注册华为失败的错误原因。 然后根据 华为开发文档 对应的错误码查找原因，以及解决办法。 若还不能解决，可以在cmd里执行adb shell setprop log.tag.hwpush VERBOSE和adb shell logcat -v time > D:/log.txt 开始抓日志，然后进行测试，测完再关闭cmd窗口。将log发给我们的技术支持。 如果需要通过消息点击回调来获取参数或者跳转自定义页面，可以通过使用Intent方式来实现，点击查看教程 代码混淆 -ignorewarning -keepattributes *Annotation* -keepattributes Exceptions -keepattributes InnerClasses -keepattributes Signature -keepattributes SourceFile,LineNumberTable -keep class com.hianalytics.android.**{*;} -keep class com.huawei.updatesdk.**{*;} -keep class com.huawei.hms.**{*;} 厂商通道测试方法 在您的App中集成信鸽V3.2.1以上版本的SDK，并且按照「厂商通道集成指南」集成所需的厂商SDK 确认已在信鸽管理台中「应用配置-厂商&海外通道」中填写相关的应用信息。通常，相关配置将在1个小时后生效，请您耐心等待，在生效后再进行下一个步骤 将集成好的App（测试版本）安装在测试机上，并且运行App 保持App在前台运行，尝试对设备进行单推/全推 如果应用收到消息，将App退到后台，并且杀掉所有App进程 再次进行单推/全推，如果能够收到推送，则表明厂商通道集成成功 注：如果需要通过点击回调获取参数或者跳转自定义页面，可以通过使用Intent来实现，点击查看教程 "},"android_access/meizu_push.html":{"url":"android_access/meizu_push.html","title":"魅族推送通道集成指南","keywords":"","body":"魅族推送通道集成指南 魅族推送通道是由魅族官方提供的系统级推送通道。在魅族手机上，推送消息能够通过魅族的系统通道抵达终端，并且无需打开应用就能够收到推送。使用此功能必须先集成信鸽 3.2.1-beta 以上版本。 [注意事项] 魅族推送通道通知标题不超过32字符，通知内容不超过100字符 魅族推送通道不支持透传消息 获取魅族推送密钥 1.打开魅族推送官网 2.注册/登录开发者账号。（如果您是新注册账号，进行实名认证大约需要2天左右时间，具体请咨询魅族侧） 3.在魅族推送平台（http://push.meizu.com） 中新建应用。注意「应用包名」需跟您在信鸽填写的包名保持一致 4.获取应用相关的信息，并且将这些信息复制，填入信鸽管理台“应用配置”-“厂商&海外通道”栏目，这些信息是AppID，AppKey，AppSecret 注：更多详情请参照魅族开发文档 5.在信鸽管理台-应用配置-厂商&海外通道处-魅族推送通道处，将相关推送密钥填入。 集成方式 AndroidStudio集成方式 1.在项目模块下的build.gradle中添加魅族通道所需要依赖（使用Androidstudio默认仓库jcenter）: 以下两个版本请根据需要选择其中之一 //集成信鸽的基础上新增魅族push的jar包 compile 'com.tencent.xinge:xgmz:3.2.2-release' /* 魅族 3.2.4-beta版 * 注意：若魅族通道使用此版本,则信鸽sdk版本也需要同时使用v3.2.4-beta */ compile 'com.tencent.xinge:xgmz:3.2.4-beta' 2.配置魅族消息receiver。注：如果使用xgmz:3.2.4-beta版本则不需要此步骤，只需要添加依赖即可 Eclipse集成方式 1.将魅族通道所需要的jar包（pushsdk-3.3.170110.jar）导入libs目录下： 2.在Androidmanifest下配置一下配置： 魅族消息receiver 如需要自定义魅族消息的广播需要新建类继承（MzPushMessageReceiver）。然后在Androidmanifest.xml中配置一下节点： 启动代码已经注册日志输出 在启动信鸽(调用 XGPushManager.registerPush )之前配置如下代码： //设置魅族APPID和APPKEY XGPushConfig.enableOtherPush(context, true); XGPushConfig.setMzPushAppId(this, APP_ID); XGPushConfig.setMzPushAppKey(this, APP_KEY); 注册成功的日志如下： //成功的获取到信鸽的token和魅族的token，并且绑定成功说明注册成功 INFO16:24:27.94313075XINGE[a] >> bind OtherPushToken success ack with [accId = 2100273138 , rsp = 0] token = 08d7ea8e4b93952cbfdd2cb68461342c314d281a otherPushType = meizu otherPushToken = ULY6c5968627059714a475c63517f675b7f655e62627e 注：如果需要通过点击回调获取参数或者跳转自定义页面，可以通过使用Intent来实现，点击查看教程 代码混淆 -dontwarn com.meizu.cloud.pushsdk.** -keep class com.meizu.cloud.pushsdk.**{*;} 厂商通道测试方法(通用) 在您的App中集成信鸽V3.2.1以上版本的SDK，并且按照「厂商通道集成指南」集成所需的厂商SDK 确认已在信鸽管理台中「应用配置-厂商&海外通道」中填写相关的应用信息。通常相关配置将在1个小时后生效，请您耐心等待，在生效后再进行下一个步骤 将集成好的App（测试版本）安装在测试机上，并且运行App 保持App在前台运行，尝试对设备进行单推/全推 如果应用收到消息，将App退到后台，并且杀掉所有App进程 再次进行单推/全推，如果能够收到推送，则表明厂商通道集成成功 "},"android_access/mi_push.html":{"url":"android_access/mi_push.html","title":"小米推送通道集成指南","keywords":"","body":"小米推送通道集成指南 小米推送通道是由小米官方提供的系统级推送通道。在小米手机上，推送消息能够通过小米的系统通道抵达终端，并且无需打开应用就能够收到推送。使用此功能必须先集成信鸽3.2.0以上版本。 获取小米推送秘钥 (a)根据小米开放平台指引开通小米开发者账号,然后注册应用并获取小米推送的秘钥。 认证小米开发者： 获取小米推送密钥： 配置小米推送相关内容 AS开发建议使用jcenter依赖接入 1.配置包名。 manifestPlaceholders = [ PACKAGE_NAME:\"应用包名\" ] 2.引入小米推送的jar包 以下两个版本请根据需要选择其中之一 //在集成信鸽的基础上新增小米push的jar包 compile 'com.tencent.xinge:mipush:3.2.2-release' /* 小米3.2.4-beta版 * 注意：若小米通道使用此版本,则信鸽sdk版本也需要同时使用v3.2.4-beta */ compile 'com.tencent.xinge:mipush:3.2.4-beta' 3.新建一个类继承小米PushMessageReceiver，然后再Androidmanif.xml 中配置。根据小米的要求次节点必须配置 注：如果使用mipush:3.2.4-beta版本则不需要此步骤，只需要前两步即可 Eclipse开发接入 1.引入小米推送的jar包，可以在小米推送web官网下载小米的jar包。 2.在配置好信鸽的基础上 ，新增小米推送的配置: 3.新建一个类继承小米PushMessageReceiver，然后再Androidmanif.xml 中配置。根据小米的要求此节点必须配置： 开启小米推送 设置小米APPID和APPKEY。 XGPushConfig.setMiPushAppId(getApplicationContext(), \"APPID\"); XGPushConfig.setMiPushAppKey(getApplicationContext(), \"APPKEY\"); //打开第三方推送 XGPushConfig.enableOtherPush(getApplicationContext(), true); //注册成功的日志如下 12-02 16:17:32.299 12584-12584/com.qq.xgdemo I/XINGE: [XGPushManager] Action -> Register to xinge server 12-02 16:17:32.996 12584-12584/com.qq.xgdemo I/XINGE: [XGPushManager] Register call back to com.qq.xgdemo 12-02 16:17:32.997 12584-12626/com.qq.xgdemo I/XINGE: [XGPushManager] XG register push success with token : 1d31bb3ea6185baebdf05dfc2e586dfe5dc41fb5 12-02 16:17:33.001 12584-12626/com.qq.xgdemo I/XINGE: [XGOtherPush] other push token is : YZQfRxmxdfNlbSKpNWCa3tM4Esnq6op4qeOsQO2qT88= other push type: xiaomi 注：如果需要通过点击回调获取参数或者跳转自定义页面，可以通过使用Intent来实现，点击查看教程 代码混淆 -keepclasseswithmembernames class com.xiaomi.**{*;} -keep public class * extends com.xiaomi.mipush.sdk.PushMessageReceiver 厂商通道测试方法(通用) 在您的App中集成信鸽V3.2.1以上版本的SDK，并且按照「厂商通道集成指南」集成所需的厂商SDK 确认已在信鸽管理台中「应用配置-厂商&海外通道」中填写相关的应用信息。通常相关配置将在1个小时后生效，请您耐心等待，在生效后再进行下一个步骤 将集成好的App（测试版本）安装在测试机上，并且运行App 保持App在前台运行，尝试对设备进行单推/全推 如果应用收到消息，将App退到后台，并且杀掉所有App进程 再次进行单推/全推，如果能够收到推送，则表明厂商通道集成成功 "},"android_access/android_returncode.html":{"url":"android_access/android_returncode.html","title":"Android SDK 错误码对照表","keywords":"","body":"客户端返回码 错误码 原因以及解决办法 0 调用成功 2 参数错误，例如绑定了单字符的别名，或是ios的token长度不对，应为64个字符 20 鉴权错误,access id 或者 access key 配置错误 10000 起始错误 10001 操作类型错误码，例如参数错误时将会发生该错误 10002 正在执行注册操作时，又有一个注册操作到来，则回调此错误码 10003 权限配错或者缺少所需权限 10004 so库没有正确导入（Androidstudio可在main文件目录下 添加jniLibs命名的文件夹将SDK文档中的Other-Platform-SO下的7个so库文件夹添加至该目录） 10005 AndroidManifest文件的XGRemoteService节点没有配置或者的该节点的action包名配错 10008 jce JAR错误或者缺少 jce JAR（如果是混淆打包过后出现,请检查混淆代码） 10101 创建链路失败（切换网络重试） 10102 请求处理过程中， 链路被主动关闭（切换网络重试） 10103 请求处理过程中，服务器关闭链接（切换网络重试） 10104 请求处理过程中，客户端产生异常（切换网络重试） 10105 请求处理过程中，发送或接收报文超时（切换网络重试） 10106 请求处理过程中， 等待发送请求超时（切换网络重试） 10107 请求处理过程中， 等待接收请求超时（切换网络重试） 10108 服务器返回异常报文 10109 未知异常，切换网络 或者 重启设备） 10110 创建链路的handler为null 其他 如出现其他未知错误 请记录错误日志 与我们取得联系 "},"android_access/android_faq.html":{"url":"android_access/android_faq.html","title":"Android SDK 常见问题","keywords":"","body":"Android平台常见问题 收不到推送的问题 用获取到的Token，在「信鸽官网」推送。如无法收到推送请根据以下情况进行排查（请确保SDK版本是最新的版本，如果是旧版本出现问题，在新版本可能已经修复，如遇到web端推送报错，请刷新页面重试） 注册成功无法收到推送 请查看当前的应用包名是否和注册信鸽应用时填写的应用包名是否一致。如果不一致，推送的时候建议开启多包名推送 检查手机网络是是否异常，切换4G网络测试一下 信鸽推送分为「通知栏消息」，和「应用内消息」（透传消息），通知栏消息可以展示到通知栏，应用内消息不能展示到通知栏 确认手机当前模式是正常模式，部分手机在低电量，勿扰模式，省电模式下，会对后台信鸽进程进行一系列网络和活动的限制 查看设备是否开启通知栏权限，oppo,vivo等手机，需要手动开启通知栏权限 注册不成功无法收到推送 新创建的app会有一分钟左右的数据同步过程，在此期间注册可能返回20错误码，稍后重试即可 [参数填写有误] access id和access key是否正确配置，常见错误是误用secret key或者access key头尾有空格 [注册返回错误] 若控制台返回「10004」、「10002」、「20」等错误码，请参考：Android SDK 错误码对照表 [注册无回调] 是否添加 wup包 确认当前 网络情况 是否良好,建议使用4G网络测试，WIFI由于使用人数过多可能造成 网络带宽不 足 努比亚手机 在2015年下半年和2016年出的机器都无法注册，具体机型包括「Nubia Z11系列」，「NubiaZ11S系列」，「NubiaZ9S系列」。可以的注册的机器都是之前的机器，包括「Z7系列」，「My布拉格系列」（在信鸽2.47和信鸽3.X上都有这个现象） 关闭应用无法收到推送 目前第三方推送都无法保证关闭应用过后还可以收到推送消息，这个是手机定制ROM对信鸽service的限制问题，信鸽的一切活动都需要建立在信鸽的service能够正常联网运行，service被终止后，由系统、安全软件和用户操作限定是否能够再次启动 QQ，微信是系统级别的应用白名单，相关的service不会应用关闭应用而退出所以用户感知推出应用过后还可以收到消息其实相关的service 还是能够在后台存活的 Android端在应用退出，信鸽service和信鸽的服务器断开连接后，这个时候给这个设备下发的消息，会变成离线消息，离线消息最多保存72消息，每个设备最多保存两条，如果有多条离线消息。在关闭应用期间推送的消息，如开启应用无法收到，请检查是否调用了反注册接口：XGPushManager.unregisterPush(this); 账号推送收不到 「账号」，又称「别名」，指带有账号登录功能的APP的用户账号，这里不仅仅是QQ或微信，只要是用户的账号都支持，比如手机QQ的账号就是QQ号码，gmail的账号就是邮箱，中国移动的账号就是手机号码。 对于希望根据帐号进行推送的用户，首先需要将账号与Token进行绑定，否则将无法推送成功。Android绑定账号在注册时绑定，即：registerPush(context,account)接口，ios通过setAccount设置。 选择帐号推送时，提示Token not found,check registration，说明账号没和Token关联上，这种情况有两种可能： （1）账号或别名注销了，不一定是app调用，某些情况下可能会自动触发注销的 （2）该设备注册了别的账号或别名，这样会自动与原来的解绑。（一个设备只能对应一个别名如果当前别名下没有设备了，就not found了） 绑定账号后，可以通过指定别名（账号）下发通知。通常情况下，这个账号最近登陆过的设备都可以收到通知。用户账号退出时，调用registerPush(context,\"*\")解除当前账号的绑定。 账号（别名）不允许单字符，一个Token只能绑定一个账号，多次绑定时，以最后一次为准。 **注意：**一个帐号（即别名，account）下面最多可以绑定15台设备，当绑定满后，最新绑定的设备会随机顶掉之前绑定的一台设备TokenToken 标签推送收不到 [1] 请确认tag标签是否绑定成功，一个应用最多有10000个 标签「tag」， 每个Token在一个应用下最多100个 标签「tag」， 标签「tag」中不准包含空格 用服务端推送SDK来查询「tag」与「Token」绑定关系 /** * 查询token的标签 */ public function QueryTokenTags($deviceToken) { $ret = array('ret_code' => -1); if (!is_string($deviceToken)) { $ret['err_msg'] = 'deviceToken is not valid'; return $ret; } $params = array(); $params['access_id'] = $this->accessId; $params['device_token'] = $deviceToken; $params['timestamp'] = time(); return $this->callRestful(self::RESTAPI_QUERYTOKENTAGS, $params); } [2] 目前信鸽管理台只支持预设置的省份、版本、不活跃用户三种标签的推送，可以使用服务端sdk进行自定义标签的查询和推送 推送数据问题 [推送暂停] 全量推送限制(V2、V3)： 全量推送每小时最多只能创建30次推送，超过30次会被暂停。 相同内容的全量推送每小时只能推送一次，超过一次推送会被暂停。 标签推送限制(V3)： 同一标签每小时最多只能创建30次推送，超过30次会被暂停。 同一标签相同内容的推送每小时只能推送一次，超过一次推送会被暂停。 [效果统计] 次日：推送完第二天才能看到推送数据 实时：推送完马上可以看到推送数据。目前每周仅支持14次的实时数据统计 [实发量] 在消息离线保存时间内，有成功连接到信鸽服务器，并且有正常下发的量。（如：消息离线保存时间为3天，实发数据会在第四天稳定，数据会随着设备不断开启连接到信鸽服务器的数量而增加） [历史明细] 历史明细只展示：全量推送、tag推送、和官网的号码包推送。\u0010（其他推送接口不展示推送详情） [数据概览] 展示的是当天的数据，某天的数据是在那一天中各种推送行为的推送总量。（分为单推，广播也就是批量和全量推送，通知栏消息和应用内消息四类） 消息点击事件以及跳转页面方法 由于目前SDK点击消息默认会有点击事件，默认的点击事件是打开主界面。所以在终端点击消息回调的「onNotifactionClickedResult」方法内设置跳转操作时，自定义的跳转和默认的点击事件造成冲突。结果是点击之后会跳转到指定界面过后再回到主界面，所以不能再「onNotifactionClickedResult」内设置跳转 解决办法如下(推荐使用第一种方式)： [1] 使用Intent来跳转指定页面（Android 3.2.3 以上版本使用此方式） 需要在客户端app的manifest上配置要跳转的页面，如要跳转AboutActivity指定页面： 若使用服务端SDK设置intent进行跳转，可设置intent为（以Java SDK为例）：action.setIntent(\"xgscheme://com.xg.push/notify_detail\"); 如果要带上param1和param2等参数可以这么设置： action.setIntent(\"xgscheme://com.xg.push/notify_detail?param1=aa&param2=bb\"); 终端获取参数： 在你跳转指定的页面onCreat方法里面： Uri uri = getIntent().getData(); if (uri != null) { String url = uri.toString(); String p1= uri.getQueryParameter(\"param1\"); String p2= uri.getQueryParameter(\"param2\"); } [2] 在下发消息的时候设置点击消息要跳转的页面 （a）可以直接在web端高级功能内设置deeplink包名+类名） ; （b）后台设置Messege 类中的 Action字段的 的SetActivity方法（包名+类名），通过XGPushClickedResult 可以获取到消息的相关内容: 标题 ，内容和附加参数 后台设置跳转页面的方法如下（以javaSDK为例）： ...... XingeApp android = new XingeApp(accessID,secretkey); Message message_android =new Message(); message_android.setExpireTime(86400); message_android.setTitle(\"信鸽推送\"); message_android.setType(1); message_android.setContent(\"android test2\"); ClickAction action =new ClickAction(); action.setActivity(\"com.qq.xgdemo.activity.SettingActivity\"); message_android.setAction(action); JSONObject ret1 = android.pushSingleDevice(\"token\",message_android); ...... 终端获取Message 个参数的方法如下: //this必须为点击消息要跳转到页面的上下文。 XGPushClickedResult clickedResult = XGPushManager.onActivityStarted(this); //获取消息附近参数 String ster = clickedResult.getCustomContent(); //获取消息标题 String set = clickedResult.getTitle(); //获取消息内容 String s = clickedResult.getContent(); [3] 发应用内消息到终端，用户自定义通知栏，采用本地通知弹出通知，设置要跳转的页面 信鸽Android SDK集成厂商通道相关问题 厂商通道功能支持 小米通道支持抵达回调，不支持点击回调 华为通道不支持抵达回调，支持点击回调（需要自定义参数） 魅族通道不支持透传 注：如果需要通过点击回调获取参数或者跳转自定义页面，可以通过使用Intent来实现，点击查看教程 调试过程中可能遇到的otherpushToken = null的问题 [小米通道排查路径] 检查信鸽SDK版本是否为V3.2.0以上版本 根据开发文档检查manifest文件配置，尤其是需要修改包名的地方是否修改 在信鸽注册前是否设置了小米的APPID和APPKEY，以及第三方推送有没有启动 //打开第三方推送 XGPushConfig.enableOtherPush(this,true); // 设置小米的Appid和Appkey XGPushConfig.setMiPushAppId(this,MIPUSH_APPID); XGPushConfig.setMiPushAppKey(this,MIPUSH_APPKEY); APP包名是否和小米开推送平台注册的包名一致 通过实现自定义的继承PushMessageReceiver的广播来监听小米的注册结果，查看注册返回码 启动logcat，观察tag为PushService的日志，看看有什么错误信息 [华为通道排查路径] 检查信鸽SDK版本是否为V3.2.0以上版本以及 华为手机中【设置】->【应用管理】->【华为移动服务】的版本信息是否大于2.5.3 按照开发文档华为通道接入指南部分检查manifest文件配置 在信鸽注册之前是否启动了第三方推送，以及华为APPID是否配置正确 APP的包名和华为推送官网上的包名是否一致 在注册代码之前调用：XGPushConfig.setHuaweiDebug(true),手动确认给应用存储权限，然后查看SD卡目录下的hauwei.txt文件内输出的华为注册失败的错误原因，然后根据华为开发文档对应的错误码查找原因 cmd里执行adb shell setprop log.tag.hwpush VERBOSE和 adb shell logcat -v time > D:/log.txt 开始抓日志，然后进行测试，测完再关闭cmd窗口。将log发给技术支持 [魅族通道排查路径] 和小米通道的排查方法类似，参考小米通道的排查路径即可 常见问题FAQ 问: 在信鸽管理台中创建Token单推之后，历史明细中为什么没有推送记录？ 答: 信鸽管理台中的推送历史明细只展示全量推送、标签推送和官网的号码包推送，不能展示单个Token或者 账号推送 问: 应用关闭或结束进程后，还能收到推送消息吗？ 答：信鸽推送主要依赖信鸽的service进行消息的收发，杀死进程之后信鸽service也被杀死，只能等待service 被拉活或重启app才可以收到推送。若手机中有其他接入信鸽的app被打开，则可以利用其他app的service接收消息， 但共享service通道也受手机ROM限制，无法保证百分之百的成功率 问: 对单个设备，保存多少条离线信息？保存时间？ 答: 离线消息Android最多保存2条，iOS最多保存1条；保存时间最多72小时 问: 标签方面限制？ 答: 单个设备最多设置100个标签，单个app全局最多可以有10000个不同的标签 问: 当第一次注册成功后，没有反注册，以后使用还需要注册吗？ 答: 不需要，只要没反注册，就不需要再次注册 问: 设备注册为什么收不到回调信息？ 答: 注册操作中，后台只可能有三种出错行为： (1)不响应； (2)返回错误格式的数据包； (3)返回错误码。这三种行为终端应该都可以检测到并给出回调 问: Token与Account区别？ 答: Token是APP接收推送消息（device）的标识，账号是一个用户（users）的标识 问: 账号在设备A上登录过，又在设备B上登录？给这个账号发信息会怎么样？ 答: 设备B上能够收到推送。设备A无法收到推送 问: 标签与账号的区别？ 答: 标签是用于标识一个Token或用户的一些属性，如广东省、男性、游戏玩家等。帐号是用户的账号，请勿 用标签作为别名使用 问：指定打开某个activity页面，但经常不能正常跳转 答：在部分手机，通知栏跳转到某个页面可能会出现权限问题 处理方法：在androidManifest.xml中，需要打开的activity加上android:exported=\"true\" 问: 在应用列表中看到「覆盖设备数」，具体指的是什么？ 答: 是指该应用下处于注册状态的设备数/终端数，同时也是该应用在推送时可以覆盖到的最大设备数。终端若调用了 反注册unregister的接口，覆盖设备数会减少 问：为什么libs目录下有很多平台的.so文件，如armabi、x86 答：信鸽针对android所有的平台开发了.so库 处理方法：可以将不需要的平台目录删除掉，如游戏一般只有armabi，可以删除其它目录 问: 为什么在web端推送出现服务器繁忙？ 答: 请先检查Token以及所选推送环境是否正确，然后检查证书是否正确提交，若还出现相同错误可重新制作一份 不带密码的证书提交再试 问: 推送过程中，非定时推送（立即推送）能否撤销？ 答: 不能，只有返回push_id的任务才可以做撤销操作。 问: 推送后查看推送列表，已经推送完成了，状态却显示推送中，怎么办？ 答: 网页有延迟，刷新再试试 问: 用户重连上线后收到多条push的顺序是怎样？ 答: 按照消息ID递增。客户端也是按照此规则收取消息，因此，收消息的顺序就是发消息的顺序 问: 我现在有安卓的用户和iOS的用户，那我php后台要写两个不同的接口分别推给安卓用户和ios用户吗？ 答: 需要调用两次推送接口 也可以把两个封装为一个 问: 如果定时push选择的是过去的时间，是不是不会push出去？ 答: 不是，选择过去的时间系统则会立刻发送 问: 为什么会出现推送通知时，只有声音却没有文字信息的情况？ 答: 该问题与系统有很大关系，需要拿设备的logcat来进行特定分析 问：信鸽推送是否支持海外 答：只要能ping通信鸽服务器域名 openapi.xg.qq.com 就能够收到推送消息，信鸽海外服务器部署在香港，由于 在海外地区网络延时较高，信鸽在海外的推送效果会略低于在国内的推送效果 问: 信鸽与腾讯开放平台的APPID数据是否相通？ 答：当你在开放平台注册应用并使用信鸽后，应用的信息会自动从开放平台同步至信鸽平台，单独使用信鸽时不用重 新接入应用。但是在信鸽接入的应用不会同步至开放平台 问：没有sd卡就不能用信鸽了么? 答：不会，只是日志写的地方不同 问：注册方法能不能放到线程里创建，能不能在APPLICATON onCreate里就创建? 答：注册方法可以在任何地方调用，但注意要传递applicationContext 问：如何删除注册成功的Toast提示? 答：demo里面的CustomPushReceiver自带Toast提示处理方法：删除CustomPushReceiver里面的Toast 相关内容 "},"android_access/xg_demo.html":{"url":"android_access/xg_demo.html","title":"Android SDK Demo使用方法","keywords":"","body":"测试Demo的使用方法 下载Demo 一. \bDemo工程的未知在信鸽SDK文档内下载SDK. 二. 在信鸽的web端注册测试应用，测试应用名称不限，包名必须为com.qq.xgdemo,然后获取注册应用的AccessID和Accesskey. 二. 将SDK内的demo工程导入相应的开发工具。并修改工程内配置信鸽ID和key的节点。 [AndroidStudioDemo] 将注册测试应用获取到的 ACCESSID 和 ACCESSKEY 配置到测试工程内app模块下的build.gradle文件内的manifestPlaceholders节点。如图所示： [eclipse] 将注册测试应用获取到的 AccessID 和 Accesskey 配置到测试工程内AndroidManifest.xml下的节点。如图所示： 运行Demo 通过log控制台，过滤信鸽日志，（日志tag为TPush），出现如下日志说明注册信鸽成功： 10-09 20:08:46.922 24290-24303/com.qq.xgdemo I/XINGE: [TPush] get RegisterEntity:RegisterEntity [accessId=2100250470, accessKey=null, token=5874b7465d9eead746bd9374559e010b0d1c0bc4, packageName=com.qq.xgdemo, state=0, timestamp=1507550766, xgSDKVersion=3.11, appVersion=1.0] 10-09 20:08:47.232 24290-24360/com.qq.xgdemo D/TPush: 注册成功，设备token为：5874b7465d9eead746bd9374559e010b0d1c0bc4 推送测试 获取日志内的设备token，打开信鸽管理创建推送： "},"ios_access.html":{"url":"ios_access.html","title":"iOS接入","keywords":"","body":"iOS接入 以下文档适应于iOS3.1.0+ SDK版本 iOS 推送服务介绍 iOS SDK 集成指南 iOS SDK API 接口文档 iOS 推送证书说明 iOS SDK 错误码对照表 iOS SDK 常见问题 老版本文档请参考以下 iOS SDK V2.5.0 完整接入 "},"ios_access/ios_push_introduction.html":{"url":"ios_access/ios_push_introduction.html","title":"iOS 推送服务介绍","keywords":"","body":"推送服务介绍 对于iOS端实现推送消息的服务涉及到三个角色：终端应用(Client App)，APNs(Apple Push Notification service)，信鸽服务器(XG Provider)。在使用信鸽推送服务实现给客户端推送消息，需要这三个角色在整个流程中相互配合，任何一个角色出现异常都可能会导致消息推送收不到。 针对iOS设备的消息推送，信鸽平台目前只借助APNs通道，暂不支持应用内自有通道的消息下发。 推送流程原理介绍 简要说明iOS客户端实现推送流程的步骤： 第一步：要求客户端设备与APNs建立TSL连接，APNs需要验证设备的有效性； 第二步：客户端App在合适的时机，借助系统提供的接口向APNs请求推送消息用的Token；(SDK 内部实现) 第三步：客户端App在合适的时机，将从APNs获取的Token注册到信鸽服务器；（SDK内部实现） 第四步：通过管理台(xg.qq.com)或者是REST API创建推送消息，然后信鸽服务器再去请求APNs下发消息； 第五步：APNs服务器接收到信鸽服务器的推送消息请求后，根据Token来将推送的消息下发到指定的设备； 以上流程可以看出，终端设备的联网状态是至关重要的。 SDK 说明 文件组成 XGPush.h，SDK提供接口的头文件； libXG-SDK.a，静态库文件； 版本说明 支持iOS 6.0+; 针对iOS 10.0+以上版本， 需要额外引入UserNotification.framework； 建议使用Xcode 8.0 +; 如果使用Xcode7及其以下的版本，需要自行配置iOS SDK来支持UserNotification框架的编译； 主要功能说明 iOS SDK是信鸽推送服务为客户端实现消息推送而提供给开发者的接口，主要负责完成： 设备Token的自动化获取和注册，降低接入门槛； 账号、标签与设备的绑定接口，以便开发者实现特定群组的消息推送，丰富推送方式； 点击量上报，统计消息被用户点击的次数； 通道介绍 关于信鸽使用的消息下发通道APNs介绍，需要了解更多，可以参照：APNs "},"ios_access/ios_access_guide.html":{"url":"ios_access/ios_access_guide.html","title":"iOS SDK 集成指南","keywords":"","body":"iOS集成接入指南 版本提示 本指南使用的 SDK版本：V3.0.2，V3.1.0，V3.1.1版本 SDK 组成 Xg-Push-SDK-iOS-3.1.1 doc 文件夹：信鸽 iOS SDK 开发指南 demo 文件夹：主要包含样例工程，信鸽 SDK 也在其中 集成步骤 开发者可根据自己的需要自行选择手动集成或自动集成方式，推荐使用信鸽一键集成工具集成。 手动集成 前往信鸽管理台注册 iOS 应用并获取 App ID和 App Key 注: App ID 对应应用 Access ID，App Key 对应应用 Access Key. 下载信鸽 SDK, 解压缩 打开 demo 目录下的 sdk 文件夹，将XGPush.h以及libXG-SDK.a添加到工程 在Build Phases下添加以下 Framework: * CoreTelephony.framework * SystemConfiguration.framework * UserNotifications.framework * libXG-SDK.a * libz.tbd * libsqlite3.0.tbd 添加完成以后,库的引用如下: 在工程配置和后台模式中打开推送,如下图 添加编译参数 -ObjC 注意：checkTargetOtherLinkFlagForObjc报错，是因为build setting中，Other link flags未添加-ObjC 在合适的时机调用启动信鸽的 API ,并根据需要实现 XGPushDelegate 协议中的方法，开启推送服务 启动信鸽服务，以下是在 AppDelegate 中做演示： @interface AppDelegate () @end -(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [[XGPush defaultManager] startXGWithAppID: appKey: delegate:]; return YES; } 在 AppDelegate 中选择实现 XGPushDelegate 协议中的方法 /** 收到推送的回调 @param application UIApplication 实例 @param userInfo 推送时指定的参数 @param completionHandler 完成回调 */ - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler { [[XGPush defaultManager] reportXGNotificationInfo:userInfo]; completionHandler(UIBackgroundFetchResultNewData); } // iOS 10 新增回调 API // App 用户点击通知 // App 用户选择通知中的行为 // App 用户在通知中心清除消息 // 无论本地推送还是远程推送都会走这个回调 #if __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_10_0 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler { [[XGPush defaultManager] reportXGNotificationResponse:response]; completionHandler(); } // App 在前台弹通知需要调用这个接口 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler { [[XGPush defaultManager] reportXGNotificationInfo:notification.request.content.userInfo]; completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert); } #endif 自动集成 使用信鸽官网的一键集成工具，仅需3步即可完成 iOS XG SDK 的接入 第一步，登录 QQ（此账号下应包含需要配置的应用） 第二步，选择应用名称，点击 Open My Project ，打开工程项目的.xcodeproj 文件 注意：此步骤会自动将启动代码插入到AppDelegate类中 第三步，为 AppDelegate 类添加 XGPushDelegate 协议 @interface AppDelegate () @end 调试 开启Debug模式 打开Debug模式可以在终端看到详细的信鸽Debug信息，方便定位问题。 [代码示例] //打开debug开关 [[XGPush defaultManager] setEnableDebug:YES]; 实现 XGPushDelegate 协议 在调试阶段，建议实现协议中的以下两个方法，从而能得到更详细的调试信息 /** @brief 监控信鸽推送服务地启动情况 @param isSuccess 信鸽推送是否启动成功 @param error 信鸽推送启动错误的信息 */ - (void)xgPushDidFinishStart:(BOOL)isSuccess error:(nullable NSError *)error; /** @brief 向信鸽服务器注册设备token的回调 @param deviceToken 当前设备的token @param error 错误信息 @note 当前的token已经注册过之后，将不会再调用此方法 */ - (void)xgPushDidRegisteredDeviceToken:(nullable NSString *)deviceToken error:(nullable NSError *)error; 观察日志 如果 Xcode 控制台显示如下相似日志，表明客户端已经正确集成 SDK。 -[AppDelegate xgPushDidFinishStart:error:], result OK, error (null) [xgpush] clientid is 331F8A86-CDF5-4C6F-BF8C-13EFB8EAD34E package Size is 359 [xgpush]Current device token is c4294001507045547bfe64581eecb95f6d6a46c9cf9a9a0878233f6c0e8e3b8f [xgpush info]msgLen's length is 108 [xgpush] 服务器返回码: 0 -[AppDelegate xgPushDidRegisteredDeviceToken:error:], result OK, error (null) 推送测试工具 为了方便用户测试SDK接入是否成功，使用此工具可以从APNs服务器或信鸽服务器测试推送是否送达。 点击下载信鸽测试助手 如遇到推送收不到，请参考iOS常见问题文档。 "},"ios_access/ios_api.html":{"url":"ios_access/ios_api.html","title":"iOS SDK API 接口文档","keywords":"","body":"SDK API说明 启动信鸽推送服务 说明 通过使用在信鸽官网注册的应用的信息，启动信鸽推送服务 接口 - (void)startXGWithAppID:(uint32_t)appID appKey:(nonnull NSString *)appKey delegate:(nullable id)delegate ; 参数说明 appID：通过前台申请的应用 ID, 即 Access ID appKey： 通过前台申请的 appKey，即 Access Key delegate：回调对象 注意：接口所需参数必须要正确填写，反之信鸽服务将不能正确为应用推送消息 示例 [[XGPush defaultManager] startXGWithAppID: appKey: delegate:]; 终止信鸽推送服务 说明 终止信鸽推送服务以后，将无法通过信鸽推送服务向设备推送消息，如果再次需要接收信鸽服务的消息推送，则必须需要再次调用 startXGWithAppID:appKey:delegate: 方法重启信鸽推送服务 接口 - (void)stopXGNotification; 示例 [[XGPush defaultManager] stopXGNotification]; 自定义通知栏消息行为 创建消息支持的行为 说明 在通知消息中创建一个可以点击的事件行为 接口 + (nullable id)actionWithIdentifier:(nonnull NSString *)identifier title:(nonnull NSString *)title options:(XGNotificationActionOptions)options; 参数说明 identifier：行为唯一标识 title：行为名称 options：行为支持的选项 示例 XGNotificationAction *action1 = [XGNotificationAction actionWithIdentifier:@\"xgaction001\" title:@\"xgAction1\" options:XGNotificationActionOptionNone]; 注意：通知栏带有点击事件的特性，只有在 iOS8.0 + 以上支持，iOS 7.x or earlier的版本，此方法返回空 创建分类对象 说明 创建分类对象，用以管理通知栏的Action对象 接口 + (nullable id)categoryWithIdentifier:(nonnull NSString *)identifier actions:(nullable NSArray *)actions intentIdentifiers:(nullable NSArray *)intentIdentifiers options:(XGNotificationCategoryOptions)options; 参数说明 identifier：分类对象的标识 actions：当前分类拥有的行为对象组 intentIdentifiers：用以表明可以通过Siri识别的标识 options：分类的特性 注意：通知栏带有点击事件的特性，只有在iOS8+以上支持，iOS 8 or earlier的版本，此方法返回空 示例 XGNotificationCategory *category = [XGNotificationCategory categoryWithIdentifier:@\"xgCategory\" actions:@[action1, action2] intentIdentifiers:@[] options:XGNotificationCategoryOptionNone]; 创建配置类 管理推送消息通知栏的样式和特性 接口 + (nullable instancetype)configureNotificationWithCategories:(nullable NSSet *)categories types:(XGUserNotificationTypes)types; 参数说明 categories：通知栏中支持的分类集合 types：注册通知的样式 示例 XGNotificationConfigure *configure = [XGNotificationConfigure configureNotificationWithCategories:[NSSet setWithObject:category] types:XGUserNotificationTypeAlert|XGUserNotificationTypeBadge|XGUserNotificationTypeSound]; 上报地理位置 说明 上报地理位置信息，后续可以使用信鸽针对位置进行精准推送 接口 - (void)reportLocationWithLatitude:(double)latitude longitude:(double)longitude; 参数说明 latitude：纬度 longitude：经度 示例 [[XGPush defaultManager] reportLocationWithLatitude:20.0 longitude:19.0]; 上报应用角标 说明 上报当前 App 角标数到信鸽服务器 接口 - (void)setBadge:(NSInteger)badgeNumber; 参数说明 badgeNumber 应用的角标数 注意：(后台维护中) 此接口是为了实现角标+1的功能，服务器会在这个数值基础上进行角标数新增的操作，调用成功之后，会覆盖之前值 示例 [[XGPush defaultManager] setXgApplicationBadgeNumber:0]; 管理应用角标 说明 管理 App 显示的角标数量 接口 @property (nonatomic) NSInteger xgApplicationBadgeNumber; 示例 // 设置应用角标 [[XGPush defaultManager] setXgApplicationBadgeNumber:0]; // 获取应用角标 NSInteger number = [[XGPush defaultManager] xgApplicationBadgeNumber]; 统计推送效果 说明 为了更好的了解每一条推送消息的运营效果，需要将用户对消息的行为上报 需要调用上报数据的接口 接口 - (void)reportXGNotificationInfo:(nonnull NSDictionary *)info; 示例 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [[XGPush defaultManager] reportXGNotificationInfo:launchOptions]; return YES; } iOS 9.x 及以前，需要在 UIApplicationDelegate 的回调方法(如下)中调用上报数据的接口 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler { } 示例 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler { [[XGPush defaultManager] reportXGNotificationInfo:userInfo]; completionHandler(UIBackgroundFetchResultNewData); } iOS 10.0 + ，需要在 XGPushDelegate 的回调方法(如下)中调用上报数据的接口 示例 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler { [[XGPush defaultManager] reportXGNotificationInfo:response.notification.request.content.userInfo]; completionHandler(); } 如果需要实现应用在前台时，也可以展示推送消息，需要实现以下方法，并在其中调用上报接口 接口 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler; 示例 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler { [[XGPush defaultManager] reportXGNotificationInfo:notification.request.content.userInfo]; completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert); } 管理设备 Token 查询设备 Token 说明 查询当前应用从 APNs 获取的 Token 字符串 接口 @property (copy, nonatomic, nullable, readonly) NSString *deviceTokenString; 示例 NSString *token = [[XGPushTokenManager defaultTokenManager] deviceTokenString]; 查询 APNs 注册结果 说明 如果注册成功，则应用会调用 UIApplicationDelegate 代理对象的回调方法(如下)， 接口 - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken; 查询信鸽注册结果 说明 SDK 的启动方法自动注册设备从 APNs 获取的 Token 到信鸽服务器，注册结果会在 XGPushDelegate (以下)的回调方法返回 接口 - (void)xgPushDidRegisteredDeviceToken:(NSString *)deviceToken error:(NSError *)error; 注意：此回调方法在注册成功之后调用，当前的 Token 已经注册过之后，SDK 将缓存注册信息，此方法将不会再调用 绑定/解绑 标签和账号 说明 开发者可以针对不同的用户绑定标签,然后对该标签推送.对标签推送会让该标签下的所有设备都收到推送.一个设备可以绑定多个标签. 接口 - (void)bindWithIdentifier:(nullable NSString *)identifier type:(XGPushTokenBindType)type; - (void)unbindWithIdentifer:(nullable NSString *)identifier type:(XGPushTokenBindType)type; 参数说明 identifier:标签或账号 type:绑定类型 示例 //绑定标签： [[XGPushTokenManager defaultTokenManager] bindWithIdentifier:@\"your tag\" type:XGPushTokenBindTypeTag]; //解绑标签 [[XGPushTokenManager defaultTokenManager] unbindWithIdentifer:@\"your tag\" type:XGPushTokenBindTypeTag]; //绑定账号： [[XGPushTokenManager defaultTokenManager] bindWithIdentifier:@\"your account\" type:XGPushTokenBindTypeAccount]; //解绑账号： [[XGPushTokenManager defaultTokenManager] unbindWithIdentifer:@\"your account\" type:XGPushTokenBindTypeAccount]; 查询绑定的标签和账号 说明 根据指定类型查询当前 Token 对象绑定的标识 接口 - (nullable NSArray *)identifiersWithType:(XGPushTokenBindType)type; 示例 // 查询标签 [[XGPushTokenManager defaultTokenManager] identifiersWithType:XGPushTokenBindTypeTag]; // 查询账号 [[XGPushTokenManager defaultTokenManager] identifiersWithType:XGPushTokenBindTypeAccount]; 查询设备通知权限 说明 查询设备通知权限是否被用户允许 接口 - (void)deviceNotificationIsAllowed:(nonnull void (^)(BOOL isAllowed))handler; 参数说明 handler：查询结果的返回方法 示例 [[XGPush defaultManager] deviceNotificationIsAllowed:^(BOOL isAllowed) { }]; 查询 SDK 版本 说明 查询当前 SDK 的版本 接口 - (nonnull NSString *)sdkVersion; 示例 [[XGPush defaultManager] sdkVersion]; 本地推送 本地推送相关功能请参考苹果开发者文档. "},"ios_access/ios_push_certificate.html":{"url":"ios_access/ios_push_certificate.html","title":"iOS 推送证书说明","keywords":"","body":"iOS推送证书说明 消息推送证书介绍 本指南用于介绍如何生成信鸽推送所需要的iOS 消息推送证书。 iOS 推送证书分为开发环境的推送证书和发布环境的推送证书。 按照本教程，分别制作开发环境和发布环境的推送证书。 APNs 推送证书申请 第一步：制作消息推送证书请求文件 首先，打开 Keychain Access 工具 然后，选择 Request a Certificate From a Certificate Authority 最后，填写邮件地址，其它留空，将证书保存到本地 第二步：配置应用，使其拥有推送能力 首先，登录苹果开发者中心网站点击 Certificates,Identifiers & Profiles 然后，选中需要制作消息推送证书的应用，勾选消息推送服务 下面以制作开发环境的消息推送证书为例演示，发布环境的消息推送证书操作步骤基本一致 第三步：创建消息推送证书 首先，点击 Create Certificate 然后，选择第一步中创建的消息推送证书请求文件，上传完毕之后，点击 Generate 最后，将生成的消息推送证书下载到本地 第四步，安装证书 双击上一步中下载的证书，会自动将消息推送证书安装到 Keychain 应用中 第五步，导出证书 打开 Keychain Access选中需要导出的消息推送证书，右键，选择导出证书，导出的格式为P12，设置密码 信鸽推送专用格式证书制作 信鸽推送服务，目前仅支持PEM格式的推送证书，需要接入方将上面步骤中导出的P12格式的推送证书转换为PEM格式。 以下介绍了两种制作方法： 自动生成 首先，下载信鸽推送测试助手 其次，打开App，选择APNs服务器，并上传P12格式的推送证书文件，输入密码(必须)，点击Push，工具将会在同一目录下生成信鸽专用的PEM格式的文件。 手动生成 openssl pkcs12 -in CertificateName.p12 -out CertificateName.pem -nodes 上传证书 第一步：登录信鸽前端管理台 第二步：在【应用列表】中选择需要上传推送证书的应用 第三步：在【应用配置】页面上传对应环境的推送证书即可完成 "},"ios_access/ios_returncode.html":{"url":"ios_access/ios_returncode.html","title":"iOS SDK 错误码对照表","keywords":"","body":"错误码对照表 Code 描述 调试办法 -10000 客户端终止信鸽服务 可能是调用了stop接口，没有再次注册的情况下有其他操作 -10001 SDK启动函数中必须的参数错误 查看start接口中参数是不是正确填写了 -10002 标识已做过绑定或者是解绑操作 调用查询标识接口，查看标识状态 -10003 网络未连接 确认设备的联网状态 -10004 SDK未能获取到设备Token 确认设备的联网状态，开启debug，查看token的打印情况 -101 md5值错误 检查启动参数填写正确 -102 账号为空 检查绑定接口中的标识参数是否为空 -201 注册信鸽失败 检查设备联网状态 -202 标签操作失败 检查设备联网状态 -203 消息统计上报失败 检查设备联网状态；检查消息体中是否有xg字段 -204 注销信鸽服务失败 检查设备联网状态 -205 上报角标失败 检查设备联网状态 -301 注册信鸽时，SDK内部错误 更新SDK最新版本 -302 标签操作时，SDK内部错误 更新SDK最新版本 -303 消息统计上报时，SDK内部错误 更新SDK最新版本 -304 注销信鸽服务时，SDK内部错误 更新SDK最新版本 -305 上报角标时，SDK内部错误 更新SDK最新版本 其他错误码请参照REST API中的错误码一览 "},"ios_access/ios_faq.html":{"url":"ios_access/ios_faq.html","title":"iOS SDK 常见问题","keywords":"","body":"iOS常见问题排查 推送消息收不到 消息推送是一个涉及到很多关联模块协作的任务，每一个环节出现异常都可能会导致消息收不到，以下是最为常见的问题： 客户端排查 检查设备通知设置 请检查【通知】---【应用名】，查看您的应用是不是打开了推送消息权限。 检查设备网络设置 设备网络问题，可能导致客户端在注册 APNs 时获取接收消息的标识(Token)失败，这会导致无法使用信鸽推送服务给指定设备推送消息； 进一步说，即使是客户端正确获取 Token，且已经将 Token 注册到信鸽后台，当使用信鸽服务器推送下发消息成功时，如果是设备未联网的状态，客户端将无法收到消息；若设备在短时内恢复网络连接，可能还会收到消息( APNs 会持有一段时间，然后再次下发消息) SDK 接入问题，在接入 SDK 之后，请确保能够获取到接收消息的标识(Device Token)，具体参考iOS SDK 集成指南 服务器排查 APNs服务器问题 由于信鸽服务针对 iOS 设备下发消息是通过 APNs 服务下发，若 APNs 出现故障，将直接导致信鸽服务器请求 APNs 给设备下发消息失败 信鸽服务器问题 信鸽服务端使用了多个功能模块之间的协作方式完成消息的下发，若其中任何一个模块有问题，也会导致消息推送出现问题 推送证书排查 信鸽服务器在向 APNs 请求消息下发的时候，需要使用两个必需的参数：消息推送证书和设备标识(Device Token)，在进行消息推送的时候，请确保消息推送证书是有效的。关于消息推送证书的设置可以参考iOS 推送证书说明 为了验证服务器的问题，可以借助信鸽测试助手，此工具不仅可以帮助验证信鸽服务器和APNs服务器，还能验证消息推送证书的有效性、自动生成信鸽专用的消息推送证书的格式。 在通过信鸽管理台上传证书之后，证书的生效之间一般是需要 5 分钟左右 账号/标签绑定和解绑为什么不起作用 使用 SDK API 进行账号和标签的绑定或者是解绑操作，信鸽服务器需要10s左右进行数据同步 新版本中注册 Token 的接口不见了 在iOS SDK 3.1.0 + 版本之后，设备标识(Device Token)的注册实现了自动化，由 SDK 内部处理，不再需要开发者手动调用 iOS 应用角标数量是不是支持自动设置 信鸽服务器暂时还不支持实现角标数量的逻辑控制，目前仍在研发中 若急需要实现自动化控制，需要接入方在客户端调用获取角标数量的 API，上报到接入方的服务器进行逻辑控制。 终端出现\"Error Domain=NSCocoaErrorDomain Code=3000 \"未找到应用程序的“aps-environment”的授权字符串\" UserInfo=0x16545fc0 {NSLocalizedDescription=未找到应用程序的“aps-environment”的授权字符串}\"错误 请检查 Xcode 工程中配置的 bundle id 是不是和设置的 Provision Profile 文件匹配，且对应 App 的 Provision Profile 文件是不是已经配置了消息推送能力 客户端如何根据消息内容进行跳转或者是其他响应 iOS 设备收到一条推送消息，用户点击推送推送消息打开应用时，应用程序根据状态不同进行处理： 若 App 状态为未运行，此函数将被调用 若 launchOptions 包含 UIApplicationLaunchOptionsRemoteNotificationKey ，表示用户点击推送消息导致App被启动运行； 若不含有对应键值则表示 App 不是因点击消息而被启动，可能为直接点击icon启动或其他。 代码示例 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // 消息内容获取 NSDictionary *remoteNotification = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]; // 然后根据消息内容进行逻辑处理 } 若 App 状态为正在前台或者是在后台但仍处于 Active 状态 基于 iOS 7.0+ 系统版本，如果是使用 Remote Notification 特性，那么处理函数需要使用 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler; 基于 iOS 10.0+ 的系统版本，如果是使用 Remote Notification 特性，那么处理函数建议使用新增UserNotifications Framework 来进行处理，在 iOS XG SDK3.1.0 之后的版本，信鸽 SDK 对新增的框架进行了封装，请使用 XGPushDelegate 协议中的以下两个方法： 代码示例 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler { NSLog(@\"[XGDemo] click notification\"); completionHandler(); } // App 在前台弹推送消息需要调用这个接口 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler { completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert); } 客户端如何播放自定义推送消息音频 首先，终端开发侧，把音频文件放到 bundle 目录下； 若使用信鸽管理台创建推送时，在【高级设置】中填写音频文件名称(不需要音频文件的全路径) 若使用 REST API 调用时，将 sound 参数设为音频文件名即可(不需要音频文件的全路径) iOS 是否支持离线保存 不支持，信鸽服务器下发消息请求到 APNs，若 APNs 发现设备不在线，APNs 会持有一段时间，具体时长APNs并未给出明确的说明 为什么iOS没有抵达数据 对于 iOS 9.x之前，操作系统未提供API接口来监听消息抵达终端，故而无法统计 iOS 10.0+，操作系统提供了 Service Extension 接口，可供客户端调用，从而可以监听消息的到达，但目前信鸽iOS 消息统计数据未计算这部分数据，敬请期待。 用信鸽服务端 SDK ，怎么创建静默推送 给参数 content-available赋值1，同时不使用 alert、badge、sound "},"ios_access/api_2.5.0.html":{"url":"ios_access/api_2.5.0.html","title":"iOS SDK v2.5.0 完整接入","keywords":"","body":"信鸽 iOS SDK 开发指南 简介 信鸽iOS SDK是一个能够提供Push服务的开发平台，提供给开发者简便、易用的API接口，方便快速接入。 接入方法 (1)获取 AppId 和 AppKey (2)工程配置 获取 AppId 和 AppKey 前往http://xg.qq.com注册并获取AppKey 工程配置 （1）下载信鸽 SDK, 解压缩。注：使用CocoaPods的用户可以通过如下名称管理信鸽： pod 'QQ_XGPush' （2）将 XGSetting.h, XGPush.h 以及 libXG-SDK.a 添加到工程 （3）添加以下库/framework 的引用 CoreTelephony.framework, SystemConfiguration.framework, UserNotifications.framework, libXG-SDK.a 以及 libz.tbd.添加完成以后,库的引用如下 （4）在工程配置和后台模式中打开推送,如下图 （5）参考 Demo, 添加相关代码 API 接口 开启 Debug 打开 Debug 模式以后可以在终端看到详细的信鸽 Debug 信息.方便定位问题 示例 //打开debug开关 XGSetting *setting = [XGSetting getInstance]; [setting enableDebug:YES]; //查看debug开关是否打开 BOOL debugEnabled = [setting isEnableDebug]; 初始化信鸽 在使用信鸽之前,需要先在UIApplicationDelegate中的 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions; 回调中调用信鸽的初始化方法才能正常使用信鸽 (1)接口 /** 初始化信鸽 @param appId 通过前台申请的应用ID @param appKey 通过前台申请的appKey */ +(void)startApp:(uint32_t)appId appKey:(nonnull NSString *)appKey; (2)示例 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [XGPush startApp:1234567890 appKey:@\"ABCDEFGHIJKLMN\"]; } 注册苹果推送服务 使用推送前,需要先向苹果注册推送服务. 请参考 Demo 向苹果注册推送服务. 示例 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // 详细代码参考 Demo 中 registerAPNS 的实现 [self registerAPNS]; } 注: 在 iOS 10 中也可以可以使用 iOS 10 之前的注册方法来注册推送,但是对应的,也要使用 iOS 10 之前的方法来接收推送 注册信鸽 向苹果注册完成推送服务以后,还需要向信鸽注册推送.在UIApplicationDelegate的 - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken; 回调中调用信鸽的 registerDevice 方法即可完成信鸽注册 (1)接口 /** 注册设备 @param deviceToken 通过appdelegate的didRegisterForRemoteNotificationsWithDeviceToken 回调的获取 @param successCallback 成功回调 @param errorCallback 失败回调 @return 获取的 deviceToken 字符串 */ +(nullable NSString *)registerDevice:(nonnull NSData *)deviceToken successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; /** 注册设备并且设置账号 @param deviceToken 通过appDelegate的didRegisterForRemoteNotificationsWithDeviceToken 回调的获取 @param account 需要设置的账号,长度为2个字节以上，不要使用\"test\",\"123456\"这种过于简单的字符串, 若不想设置账号,请传入nil @param successCallback 成功回调 @param errorCallback 失败回调 @return 获取的 deviceToken 字符串 */ +(nullable NSString *)registerDevice:(nonnull NSData *)deviceToken account:(nullable NSString *)account successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; /** 注册设备并且设置账号, 字符串 token 版本 @param deviceToken NSString *类型的 token @param account 需要设置的账号,若不想设置账号,请传入 nil @param successCallback 成功回调 @param errorCallback 失败回调 @return 获取的 deviceToken 字符串 */ +(nullable NSString *)registerDeviceStr:(nonnull NSString *)deviceToken account:(nullable NSString *) account successCallback:(nullable void(^)(void)) successCallback errorCallback:(nullable void(^)(void))errorCallback; (2)示例 - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken { NSString *deviceTokenStr = [XGPush registerDevice:deviceToken account:nil successCallback:^{ NSLog(@\"[XGPush Demo] register push success\"); } errorCallback:^{ NSLog(@\"[XGPush Demo] register push error\"); }]; NSLog(@\"[XGPush Demo] device token is %@\", deviceTokenStr); } 注意：account是需要设置的账号,视业务需求自定义,可以是用户的名称或者ID等,长度为2个字节以上，不要使用\"myAccount\"或者\"test\",\"123456\"这种过于简单的字符串,若不想设置账号，请传入nil 设置/删除标签 开发者可以针对不同的用户设置标签,然后对该标签推送.对标签推送会让该标签下的所有设备都收到推送.一个设备可以设置多个标签. (1)接口 /** 设置 tag @param tag 需要设置的 tag @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)setTag:(nonnull NSString *)tag successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; /** 删除tag @param tag 需要删除的 tag @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)delTag:(nonnull NSString *)tag successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; (2)示例 - (void)setTag:(NSString *)tag { [XGPush setTag:@\"myTag\" successCallback:^{ NSLog(@\"[XGDemo] Set tag success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Set tag error\"); }]; } - (void)delTag:(NSString *)tag { [XGPush delTag:@\"myTag\" successCallback:^{ NSLog(@\"[XGDemo] Del tag success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Del tag error\"); }]; } 设置/删除账号 开发者可以针对不同的用户设置账号,然后对账号推送.对账号推送会让该账号下的所有设备都收到推送. 注1: 一个账号最多绑定15台设备,超过之后会随机解绑一台设备,然后再进行注册. 注2: 老版本不带回调的接口要求设置/删除账号后再调用一次注册设备的方法,但是新版带回调的接口不需要再调用注册设备的方法 (1)接口 /** 设置设备的帐号. 设置账号前需要调用一次registerDevice @param account 需要设置的账号,长度为2个字节以上，不要使用\"test\",\"123456\"这种过于简单的字符串 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)setAccount:(nonnull NSString *)account successCallback:(nullable void(^)(void)) successCallback errorCallback:(nullable void(^)(void)) errorCallback; /** 删除已经设置的账号. 删除账号前需要调用一次registerDevice @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)delAccount:(nullable void(^)(void)) successCallback errorCallback:(nullable void(^)(void)) errorCallback; (2)示例 - (void)setAccount:(NSString *)account { [XGPush setAccount:@\"myAccount\" successCallback:^{ NSLog(@\"[XGDemo] Set account success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Set account error\"); }]; } - (void)delAccount { [XGPush delAccount:^{ NSLog(@\"[XGDemo] Del account success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Del account error\"); }]; } 注销设备 注销设备以后,可以让该设备不再接收推送. （1）接口 /** 注销设备，设备不再进行推送 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)unRegisterDevice:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; （2）示例 [XGPush unRegisterDevice:^{ NSLog(@\"[XGDemo] unregister success\"); } errorCallback:^{ NSLog(@\"[XGDemo] unregister error\"); }]; 注意：重新开启推送功能需要再次调用registerAPNS和registerDevice接口。 推送效果统计 如果需要统计由信鸽推送的点击或者打开. 统计打开 对于统计打开需要开发者在UIApplicationDelegate中的 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions; 调用 handleLaunching 方法 (1)接口 /** 在didFinishLaunchingWithOptions中调用，用于推送反馈.(app没有运行时，点击推送启动时) @param launchOptions didFinishLaunchingWithOptions中的userinfo参数 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)handleLaunching:(nonnull NSDictionary *)launchOptions successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; (2)示例 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [XGPush handleLaunching:launchOptions successCallback:^{ NSLog(@\"[XGDemo] Handle launching success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Handle launching error\"); }]; } 统计点击 iOS 10 以前的系统版本 对于 iOS 10 以前的系统版本,需要在 UIApplicationDelegate 中的 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo; 中调用 handleReceiveNotification 方法 (1)接口 /** 在didReceiveRemoteNotification中调用，用于推送反馈。(app在运行时) @param userInfo 苹果 apns 的推送信息 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)handleReceiveNotification:(nonnull NSDictionary *)userInfo successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; (2)示例 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo { NSLog(@\"[XGPush Demo] receive Notification\"); [XGPush handleReceiveNotification:userInfo successCallback:^{ NSLog(@\"[XGDemo] Handle receive success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Handle receive error\"); }]; } iOS 10 对于 iOS 10, 需要在 UNUserNotificationCenterDelegate 的 - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler; 中调用 handleReceiveNotification 方法 (1)接口 /** 在didReceiveRemoteNotification中调用，用于推送反馈。(app在运行时) @param userInfo 苹果 apns 的推送信息 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)handleReceiveNotification:(nonnull NSDictionary *)userInfo successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; (2)示例 - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler { [XGPush handleReceiveNotification:response.notification .request.content.userInfo successCallback:^{ NSLog(@\"[XGDemo] Handle receive success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Handle receive error\"); }]; completionHandler() } 本地推送 本地推送相关功能请参考苹果开发者文档. "},"server_api.html":{"url":"server_api.html","title":"服务端API接入","keywords":"","body":"服务端API接入 Rest API接入 服务端其他语言 "},"push_faq/server_api/rest.html":{"url":"push_faq/server_api/rest.html","title":"Rest API v2版本 使用指南","keywords":"","body":"Rest API 概述（V2） 信鸽推送提供遵从 REST 规范的 HTTP API，以供开发者远程调用信鸽提供的服务。接口主要分为四大类： Push API，包含多种消息推送的接口 标签 API， 主要完成标签的新增、删除、查询 账号 API，主要完成账号的查询、删除 工具类 API，用来定位问题和其他数据查询 V2版本仅支持HTTP协议，不支持HTTPs 请求方式 支持GET； 支持POST，但要求HTTP HEADER中\"Content-type\"字段要设置为\"application/x-www-form-urlencoded\" 协议描述 请求URL： http://openapi.xg.qq.com/v2/class_path/method?params 字段名 用途 备注 openapi.xg.qq.com 接口域名 无 v2 版本号 无 class_path 提供的接口类别 不同的接口有不同的路径名 method 功能接口名称 不同的功能接口有不同的名称 params 调用接口时传递的参数 1.包括两部分：通用基础参数、接口特定参数；2.所有的参数都必须为utf8编码；3.params中所有K-V对的V必须进行url encode 通用基础参数 通用基础参数是指，在各个接口请求URL结构中的params字段都需要包含(基础)的参数 具体如下表： 参数名 类型 必需 参数描述 access_id uint 是 应用唯一标识，可在xg.qq.com管理台查看 timestamp uint 是 1.unix时间戳，用于确认请求的有效期2.与服务器时间（北京时间）偏差大于valid_time,请求会被拒绝 valid_time uint 否 1.配合timestamp确定请求的有效期2.单位为秒3.最大值为6004.不传或者小于0 或者大于600 都会被设置600 sign string 是 接口鉴权，具体生成规则见鉴权方式 鉴权方式 计算公式：Sign=MD5(http_methodURIK1=V1…Kn=Vnsecret_key);（注意：参数必须按照此顺序放置） 参数名 参数描述 http_method 请求方法，GET或是POST URI 请求URL信息，包括IP或域名、URI的path部分举例说明：域名：openapi.xg.qq.com/v2/push/single_deviceIP：10.198.18.239/v2/push/single_device（注意不包括端口和请求串） K1=V1…Kn=Vn 1.将全部请求参数格式化成K=V2.将格式化后的参数以K的字典序升序排列，拼接在一起（注意：1.不包括sign参数， 2.V不应进行url encode） secret_key 接口秘钥，可在【信鸽管理台】【应用配置】【应用信息】中查询 例如： 单推接口调用： POST请求 http://openapi.xg.qq.com/v2/push/single_device 参数列表： access_id=123，timestamp=1386691200，Param1=Value1，Param2=Value2，secret_key=abcde， 根据上述公式得出： sign=MD5(POSTopenapi.xg.qq.com/v2/push/single_deviceaccess_id=123Param1=Value1Param2=Value2timestamp=1386691200abcde) 得出， sign=6b90c7f4a137c7d0b756d48f748c93b2 通用基础返回值 通用基础返回值，是所有请求的响应中都会包含的字段，JSON格式 { \"ret_code\":0, \"err_msg\":\"\", \"result\":{\"\":\"\"} } 具体描述见下表： 参数名 类型 必需 参数描述 ret_code int 是 返回码 err_msg string 否 结果描述 result JSON 否 请求正确时且有额外数据，则结果封装在该字段中 API限制 除去全量推送接口有调用频率的限制外，其他均无此限制 推送的消息体大小限制为4K，此限制适用于Push API中的message字段 标签群推限制标签数量最多是50个 Push API Push API基础参数 推送接口的基础参数是指，所有推送消息的接口的通用参数，切记接口调用参数中必须还要包含通用基础参数 具体通用参数见下表： 参数名 类型 必需 默认值 描述 message string 是 无 消息体，参见消息体格式 message_type uint 是 无 iOS平台用，必须为0，不区分通知栏消息和静默消息1，表示Android通知栏消息 2，表示Android透传消息 expire_time uint 否 3天 消息离线存储时间（单位为秒），最长存储时间3天。若设置为0，则默认值（3天）建议取值区间[800, 86400x3] send_time string 否 当前时间 1.指定推送时间,格式为yyyy-MM-DD HH:MM:SS2.若小于服务器当前时间，则会立即推送3.仅全量推送和标签群推支持此字段 multi_pkg uint 否 0 多包名推送0，按注册时提供的包名分发消息；1，忽略包名，按access id分发消息(仅Android用) environment uint 是(仅iOS) 1 此字段描述的是App的环境1，表示发布环境，对应App已经发布到AppStore2，表示开发环境，对应App仍处于调试环境(对于iOS，消息推送有两种情况：开发环境、发布环境) loop_times uint 否 无 循环执行消息下发的次数，建议取值[1, 15] loop_interval uint 否 无 循环执行消息下发的间隔，以天为单位，取值[1, 14]。loop_times和loop_interval一起表示消息下发任务的循环规则，不可超过14天 全量推送 此接口用于对全部设备推送消息，后台对本接口的调用频率有限制: 1小时内不能推相同内容的消息； 1小时内最多调用此接口30次 请求URL: http://openapi.xg.qq.com/v2/push/all_device?params 请求参数： 通用基础参数和Push API 基础参数 响应结果： 用基础返回值，result字段会包含给app下发的任务id: { \"push_id\":10000 } 如果是循环任务，返回全部任务的id 具体示例如下： { \"push_id\":10000,//父任务id \"sub_push_ids\":[234,235,236] //子任务id } 群推送 群推送是指，根据标签、账号、设备(Token)进行群组推送 标签群推 可以针对设置过标签的设备进行推送。如：性别、身份等 请求URL: http://openapi.xg.qq.com/v2/push/tags_device?params 请求参数： 除了通用基础参数和Push API 基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 tags_list JSON 是 无 [“tag1”,”tag2”,”tag3”] 限制不能超过50个，否则消息将下发失败若超过50个，推荐使用全量接口推送消息 tags_op string 是 无 运算符，取值为AND或OR 响应结果： 用基础返回值，result字段会包含给app下发的任务id { \"push_id\":10000 } 如果是循环任务，返回全部任务的id 具体示例如下： { \"push_id\":10000,//父任务id \"sub_push_ids\":[234,235,236] //子任务id } 帐号群推 账号群推是指，对通过客户端SDK绑定接口绑定的账号的群组推送，iOS和Android的SDK都提供相应的接口。 请求URL： http://openapi.xg.qq.com/v2/push/account_list?params 请求参数： 除了通用基础参数 和 Push API 基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 account_list array 是 无 JSON数组格式每个元素是一个account单次发送account不超过100个例：[“account1”,”account2”,”account3”] 响应结果： 用基础返回值，result字段的JSON为每个account发送返回码 超大批量账号群推 如果推送目标帐号数量很大（比如>100），推荐使用此方法，分为以下两步： (1)第一步，创建推送消息： 请求URL: http://openapi.xg.qq.com/v2/push/create_multipush?params 请求参数： 通用基础参数 和 Push API 基础参数 响应结果： 用基础返回值，其中result字段的JSON包含消息标识，举例如下： { \"push_id\":100000 } (2)第二步，使用超大批量推送接口进行消息推送 请求URL: http://openapi.xg.qq.com/v2/push/account_list_multiple?params 请求参数： 除通用基础参数外，还包括如下参数： 参数名 类型 必需 默认值 描述 account_list array 是 无 JSON数组格式每个元素是一个account单次发送account不超过1000个 push_id uint 是 无 创建推送消息接口返回的消息标识 响应结果： 用基础返回值 设备群推 设备群推是指，使用设备标识(Device Token)进行消息的推送 使用此接口需要2步： （1）第一步，创建消息 请求URL: http://openapi.xg.qq.com/v2/push/create_multipush?params 请求参数： 通用基础参数 和 Push API 基础参数 响应结果： 用基础返回值，其中result字段的JSON包含消息标识，举例如下： { \"push_id\":100000 } （2）第二步，调用推送接口 请求URL: http://openapi.xg.qq.com/v2/push/device_list_multiple?params 请求参数： 除了通用基础参数 ，还包括如下特定参数： 参数名 类型 必需 默认值 描述 device_list array 是 无 JSON数组格式每个元素是一个token单次发送token不超过1000个例：[“token1”,”token2”,”token3”] push_id uint 是 无 创建推送消息接口的返回的消息标识 响应结果： 用基础返回值 单推 单推，指定账号，设备标识（Device Token）进行推送 账号单推 账号单推是指，对通过客户端SDK绑定接口绑定的指定单个账号的推送，iOS和Android的SDK都提供相应的接口。 请求URL: http://openapi.xg.qq.com/v2/push/single_account?params 请求参数： 除了通用基础参数 和 Push API 基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 account string 是 无 无 响应结果： 用基础返回值 设备单推 设备单推是指，使用指定的一个设备标识(Device Token)进行消息的推送，关于设备标识的获取，客户端SDK有相应的接口 请求URL： http://openapi.xg.qq.com/v2/push/single_device?params 请求参数： 除了通用基础参数 和 Push API 基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 device_token string 是 无 设备标识 响应结果： 用基础返回值 消息体格式 消息体，即下发到客户端的消息。 Push API对iOS和Android两个平台的消息有不同处理，需要分开来实现对应平台的推送消息，推送的消息体是JSON格式，对应PushAPI接口中的message参数。 针对不同平台，消息类型稍有不同，具体参照下表： 消息类型 支持平台 特性说明 通知栏消息 Android，iOS 通知栏展示消息 透传消息 Android 通知栏不展示消息 静默消息 iOS 通知栏不展示消息 Android普通消息 Android平台具体字段如下表： 字段名 类型 默认值 必需 参数描述 title string 无 是 消息标题 content string 无 是 消息内容 builder_id int 无 是 本地通知样式标识 n_id int 0 否 通知消息对象的唯一标识1.大于0，会覆盖先前相同id的消息；2.等于0，展示本条通知且不影响其他消息；3.等于-1，将清除先前所有消息，仅展示本条消息 ring int 1 否 是否有铃声0, 没有铃声1, 有铃声 ring_raw string 无 否 指定Android工程里raw目录中的铃声文件名，不需要后缀名 vibrate int 1 否 是否使用震动0, 没有震动1, 有震动 lights int 1 否 是否使用呼吸灯0, 使用呼吸灯1, 不使用呼吸灯 clearable int 1 否 通知栏是否可清除 icon_type int 0 否 通知栏图标是应用内图标还是上传图标0，应用内图标1，上传图标 icon_res string 无 否 应用内图标文件名或者下载图标的url地址 style_id int 1 否 设置是否覆盖指定编号的通知样式 small_icon string 无 否 消息在状态栏显示的图标，若不设置，则显示应用图标 action JSON 有 否 设置点击通知栏之后的行为，默认为打开app custom_content JSON 无 否 用户自定义的键值对 accept_time array 无 否 消息将在哪些时间段允许推送给用户，建议小于10个 完整的消息示例如下： { \"title \":\"xxx\", \"content \":\"xxxxxxxxx\", \"n_id\":0, \"builder_id\":0, \"ring\":1, \"ring_raw\":\"ring\", \"vibrate\":1, \"lights\":1, \"clearable\":1, \"icon_type\":0, \"icon_res\":\"xg\", \"style_id\":1, \"small_icon\":\"xg\", \"custom_content\":{ \"key1\":\"value1\", \"key2\":\"value2\" }, \"action\":{ \"action_type\":1,// 动作类型，1，打开activity或app本身；2，打开浏览器；3，打开Intent \"activity\":\"MyActivityClassName\" \"aty_attr\":{ // activity属性，只针对action_type=1的情况 \"if\":0, // Intent的Flag属性 \"pf\":0 // PendingIntent的Flag属性 }, \"browser\":{ \"url\":\"http://xg.qq.com\", // 仅支持http、https \"confirm\":1 // 是否需要用户确认 }, \"intent\":\"xgscheme://com.xg.push/notify_detail\"// 客户端 Android SDK版本需要大于等于3.2.3，然后在客户端的intent配置data标签，并设置scheme属性 }, \"accept_time\":[//在下午1点到下午2点或者是凌晨0点到上午9点之间，消息可以展示，其他时间段，消息不会展示 { \"start\":{ \"hour\":\"13\", \"min\":\"00\" }, \"end\":{ \"hour\":\"14\", \"min\":\"00\" } }, { \"start\":{ \"hour\":\"00\", \"min\":\"00\" }, \"end\":{ \"hour\":\"09\", \"min\":\"00\" } } ] } iOS 普通消息 iOS平台具体字段如下表： 字段名 类型 默认值 必需 参数描述 aps JSON 无 是 苹果推送服务(APNs)特有的消息体字段其中比较重要的键值对:alert：包含标题和消息内容(必选)badge：App显示的角标数(可选),category：下拉消息时显示的操作标识(可选)详细介绍可以参照：Payload custom string/JSON 无 否 自定义下发的参数 xg string 无 否 系统保留key，应避免使用 完整的消息示例如下： { \"aps\":{ \"alert\":{ \"title\":\"this is a title\", \"body\":\"this is content\" }, \"badge\":1, \"category\":\"CategoryID\" }, \"custom\":{ \"key\":\"value\" } } Android透传消息 透传消息，Android平台特有，即不显示在手机通知栏中的消息，可以用来实现让用户无感知的向App下发带有控制性质的消息 Android平台具体字段如下表： 字段名 类型 默认值 是否必需 参数描述 title string 无 是 消息标题 content string 无 是 消息内容 custom_content JSON 无 否 自定义内容 accept_time array 无 否 消息将在哪些时间段允许推送给用户，建议小于10个 具体完整示例： { \"title\":\"this is title\", \"content\":\"this is content\", \"custom_content\":{ \"key1\":\"value1\", \"key2\":\"value2\" }, \"accept_time\":[//在下午1点到下午2点或者是凌晨0点到上午9点之间，消息可以展示，其他时间段，消息不会展示 { \"start\":{ \"hour\":\"13\", \"min\":\"00\" }, \"end\":{ \"hour\":\"14\", \"min\":\"00\" } }, { \"start\":{ \"hour\":\"00\", \"min\":\"00\" }, \"end\":{ \"hour\":\"09\", \"min\":\"00\" } } ] } iOS静默消息 静默消息，iOS平台特有，类似Android中的透传消息，消息不展示，当静默消息到达终端时，iOS会在后台唤醒App一段时间(小于30s)，让App来处理消息逻辑 具体字段如下表： 字段名 类型 默认值 是否必要 参数描述 aps JSON 无 是 苹果推送服务(APNs)特有的，其中最重要的键值对: content-available：标识消息类型(必须为1)且不能包含alert、sound、badge字段详细介绍可以参照：Payload custom string/JSON 无 否 自定义下发的参数 xg string 无 否 系统保留key，应避免使用 具体完整示例： { \"aps\":{ \"content-available\":1 }, \"custom\":{ \"key1\":\"value1\", \"key2\":\"value2\" } } 查询消息状态 此接口目前仅支持全量推送和标签群推消息的发送状态的查询，不支持其他推送方式的查询 请求URL： http://openapi.xg.qq.com/v2/push/get_msg_status?params 除了通用基础参数 ，还包括如下特定参数： 参数名 类型 必需 默认值 描述 push_ids array 是 无 消息唯一标识，可在管理台查看JSON格式举例： [{\"push_id\": \"10000\"}] start int 是 无 起始记录id，分页查询使用 length int 是 无 查询记录条数 type int 是 无 推送消息类型：1-通知栏消息2-透传消息（应用内消息） push_type int 否 无 方式： 1 -WEB，2-restAPI， 3-all task_type string 否 无 推送取值范围：0-所有范围（设备、账号、标签）1-设备2-帐号3-标签 platform int 否 无 平台：1-Android， 2-iOS start_date string 否 无 格式： yyyy-mm-dd end_date string 否 无 格式： yyyy-mm-dd status int 否 无 0-(所有状态)1-待推送2-推送中3-推送完成4-推送失败5-非法任务6-其他状态 message string 否 无 根据消息内容进行模糊查找 operation int 否 无 建议取值1 响应结果： 用基础返回值，其中result字段的JSON形式为： { \"Total\": \"1\", \"list\": { \"0\": { \"Content\": \"test\", //推送消息体 \"OfflineSave\": \"86400\", //Android 离线保存时间 \"ScheduleSendTime\": \"2017-04-12 17:50:00\", \"SendTime\": \"2017-04-12 17:50:01\", //根据算法从tobe_sent_tome、creat_time\\start_time中选择 \"TagsList\": \"\", //标签时的标签列表 \"Title\": \"this is title\", //推送标题 \"Type\": \"3\", //任务类型：3-全推、4-标签推送 \"cleanup\": \"0\", //清除 \"click\": \"0\", //点击 \"create_time\": \"2017-04-12 17:49:01\", //任务创建时间 \"push_active\": \"0\", //Android最近30天活跃设备 \"push_id\": \"2511161036\", \"push_online\": \"0\", //实发 \"start_time\": \"2017-04-12 17:50:01\", //任务开始推送时间 \"status\": \"2\", //0-创建任务，1-推送中，2-推送完成，4-非法任务，3-推送失败，9-内容重复，10-频率控制，11-删除离线消息，12-用户取消推送 \"verify\": \"123\", //展示 \"verify_svc\":\"0\"//到达设备数量 \"cal_type\": \"0\" } } } 取消推送 目前V2版本支持根据消息ID来取消尚未触发的、定时的、全量推送或标签群推的推送消息 请求URL： http://openapi.xg.qq.com/v2/push/cancel_timing_task?params 请求参数： 除了通用基础参数 ，还包括如下特定参数： 参数名 类型 必需 默认值 描述 push_id string 是 无 已创建的全量推送或标签群推消息的唯一标识，信鸽管理台可以查看 响应结果： 用基础返回值，其中result字段的JSON形式为： { \"status\": 0 //0为成功，其余为失败 } 标签(Tag)接口 标签接口主要是用来对标签进行查询、设置、删除操作 V2版本支持的具体接口如下： 批量新增标签 批量删除标签 查询全部标签 查询单个设备(根据Device Token)的标签 查询单个标签的设备(Device Token)总数 批量新增标签 批量新增标签，可以给多定的设备(Device Token)设置标签，但是一个 App 下面最多只能有1万个标签，若超出，此接口将返回失败 请求URL: http://openapi.xg.qq.com/v2/tags/batch_set 请求参数： 除了通用基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 tag_token_list array 是 无 JSON字符串每一个数组元素是一个tag-token对的数组每次调用最多允许设置20对每个tag-token对里面tag在前，token在后示例： [[”tag1”,”token1”],[”tag2”,”token2”]]注意:1，标签字符串长度限制在50字节以内，不可包含空格2，要求token必须是符合消息接收的设备端标识 响应结果： 用基础返回值 批量删除标签 请求URL: http://openapi.xg.qq.com/v2/tags/batch_del 请求参数： 除了通用基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 tag_token_list array 是 无 JSON字符串每一个数组元素是一个tag-token对的数组每次调用最多允许设置20对每个tag-token对里面tag在前，token在后示例： [[”tag1”,”token1”],[”tag2”,”token2”]]注意:1，标签字符串长度限制在50字节以内，不可包含空格2，要求token必须是符合消息接收的设备端标识 响应结果： 用基础返回值 查询全部标签 此接口用来查询当前指定应用下被设置的全部标签数量和对应的标签名 请求URL: http://openapi.xg.qq.com/v2/tags/query_app_tags?params 请求参数： 除了通用基础参数，还可以包括如下特定参数： 参数名 类型 必需 默认值 描述 start uint 否 0 开始索引值 limit uint 否 100 限制单次查询数量，建议小于200 响应结果： 用基础返回值中，result字段的JSON格式如下： { \"total\": 2, //指定应用的总tag数 \"tags\":[\"tag1\",\"tag2\"] //依据limit参数查询出的标签数组 } 查询单个指定设备的标签 此接口根据设备标识(Device Token)来查询相应设备被设置的全部标签，请务必保证设备标识（Device Token）的合法性 请求URL: http://openapi.xg.qq.com/v2/tags/query_token_tags?params 请求参数： 除了通用基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 device_token string 是 无 设备接收消息的标识 响应结果： 在用基础返回值参数中，result字段的JSON格式如下： { \"tags\":[\"tag1\",\"tag2\"] } 查询单个指定标签的Token总数 请求URL: http://openapi.xg.qq.com/v2/tags/query_tag_token_num?params 请求参数： 除了通用基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 tag string 是 无 需要查询的标签字符串 响应结果： 用基础返回值中，result字段的JSON格式如下： { \"device_num\":100000 } 账号(Account)接口 账号接口主要是用来查询、删除终端设备Token关联的账号 V2版本支持的具体接口如下： 查询单个账号关联的设备(Device Token) 删除单个账号关联的设备(Device Token) 删除账号关联的全部设备(Device Token) 查询单个账号关联的设备（暂可不用） 请求URL: http://openapi.xg.qq.com/v2/application/get_app_account_tokens?params 请求参数： 除了通用基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 account string 是 无 帐号标识 响应结果： 用基础返回值中，result字段的JSON格式如下： { \"tokens\":[\"token1\",\"token2\"] } 删除单个账号关联的单个设备Token 请求URL: http://openapi.xg.qq.com/v2/application/del_app_account_tokens?params 请求参数： 除了通用基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 account string 是 无 与设备标识关联的账号 device_token string 是 无 设备接收消息的标识 响应结果： 用基础返回值中，result字段的JSON格式如下： { \"tokens\":[\"token1\"] } 注意：tokens字段对应的值表示当前账号目前仍关联的设备标识 删除单个账号关联的全部设备Token 请求URL: http://openapi.xg.qq.com/v2/application/del_app_account_all_tokens?params 除了通用基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 account string 是 无 账号标识 响应结果： 用基础返回值 工具类接口 查询应用覆盖的设备Token总数 此接口用来查询指定应用的全部已注册的设备标识(Device Token)的总数 请求URL: http://openapi.xg.qq.com/v2/application/get_app_device_num?params 请求参数： 通用基础参数 响应结果： 用基础返回值，其中result字段的JSON形式为： { \"device_num\": 34567 } 查询指定设备Token的注册状态 此接口是为了查询指定设备(Device Token)在信鸽服务器上注册的状态，设备能收到信鸽推送的消息的首要条件是设备(Device Token)已经被注册到信鸽的后台，否则信鸽无法给指定设备下发消息的 请求URL: http://openapi.xg.qq.com/v2/application/get_app_token_info?params 请求参数： 除了通用基础参数，还包括如下特定参数： 参数名 类型 必需 默认值 描述 device_token string 是 无 设备接收消息的标识 响应结果： 用基础返回值，其中result字段的JSON形式为： { \"isReg\":1,//（1为token已注册，0为未注册） \"connTimestamp\":1426493097, //（最新活跃时间戳） \"msgsNum\":2 //（该应用的离线消息数） } 返回码一览 信鸽REST API接口较多，开发者使用过程中不可避难会遇到各种问题，这里提供了常见的错误码释义，对应着是用基础返回值中的ret_code字段的可能值 值 含义 可采取措施 0 调用成功 -1 参数错误 检查参数配置 -2 请求时间戳不在有效期内 检查timestamp和valid_time参数 -3-55 信鸽服务器处理错误 稍后重试 2 标签绑定错误 绑定标签时，Token或者是标签为空 6 设备token未成功注册 请检查终端设备注册是否成功 7 通用错误，账号超限 删除其他未使用的账号(调用账号解绑） 48 推送的账号没有绑定token 检查account和token是否有绑定关系 73 消息体超限 目前是4K字节 75 消息体格式不符合json格式 检查消息体即message字段内容 78 循环任务参数错误 检查loop_time 91 设备Token关联的tag过多 清理不使用的tag 92 App的关联的tag过多 清理不使用的tag，限制10000 100 APNs证书错误 信鸽使用的推送证书格式是pem，另外，注意区分生产证书、开发证书的区别 -101 参数错误 请检查通用基础参数 -102 请求时间戳不在有效期内 检查timestamp和valid_time参数 -103 sign 不合法 检查签名生成流程，生成sign是METHOD 必须与请求时所使用的一致 -104 内部错误 稍后重试 -106 证书过期 证书过期，需重新上传证书 "},"push_faq/server_api/rest_api_v3.html":{"url":"push_faq/server_api/rest_api_v3.html","title":"Rest API v3版本 使用指南","keywords":"","body":"Rest API 概述（V3） v3版本相对于v2版本的改进：1. 完全基于 HTTPs，不再提供HTTP访问2. 支持POST方式访问，不再提供GET方式访问3. 使用 HTTP Basic Authentication 的方式做访问授权。这样整个 API 请求可以使用常见的 HTTP 工具来完成，比如：curl，postman等4. API接口按照业务功能分类，类别为：Push API、标签 API、账号 API、工具类 API。每种类别的API接口采用相同的URL，提高接口易用性5. 功能方面的改进：增加送达统计的查询功能，该接口属于工具类API，目前内测中 API概述 信鸽推送提供遵从 REST 规范的 HTTP API，以供开发者远程调用信鸽提供的服务 接口主要分为四大类： API类型 描述 状态 Push API 包含多种消息推送的接口 正常 标签 API 主要完成标签的新增、删除、查询 实现中 账号 API 主要完成账号的查询、删除 实现中 工具类 API 用来定位问题和其他数据查询 实现中 本文档将只描述接口状态为正常的 API，其他状态的 API，请使用 v2 版本 请求方式 仅支持 HTTPs 仅支持 POST 权鉴方式 采用基础鉴权的方式，HTTP Header（头）里加一个字段（ Key/Value 对）： Authorization: Basic base64_auth_string 其中 base64_auth_string 的生成算法为：base64(APPID:SECRETKEY) 即对 APPID 加上冒号，加上 SECRETKEY 拼装起来的字符串，再做 base64 转换 APPID 和 SECRET KEY 可在信鸽官网【我的应用】【应用配置】中获取 协议描述 请求URL：https://openapi.xg.qq.com/v3// 字段名 用途 备注 openapi.xg.qq.com 接口域名 无 v3 版本号 无 class_path 提供的接口类别 不同的接口有不同的路径名 method 功能接口名称 不同的功能接口有不同的名称 API限制 除去全量推送、标签推送接口有调用频率的限制外，其他均无限制 推送的消息体大小限制为 4K，此限制适用于 Push API 中的 message 字段 通用基础返回值 通用基础返回值，是所有请求的响应中都会包含的字段，格式如下： { \"seq\": 0, \"push_id\": 123, \"ret_code\": 0, \"environment\": \"product\", \"err_msg\": \"\", \"result\": { \"\": \"\" } } 返回值字段描述表： 参数名 类型 必需 参数描述 seq int64 是 与请求包一致（如果请求包是非法json 该字段为0） push_id string 是 推送id ret_code int 是 错误码 environment string 是 用户指定推送环境，仅支持iOSproduct： 生产环境dev： 开发环境 err_msg string 否 结果描述 result JSON 否 请求正确时且有额外数据，则结果封装在该字段中 Push API Push API 概述 Push API 是所有推送接口的统称 Push API 有多种推送目标，推送目标如下： 全量推送 标签推送 单设备推送 设备列表推送 单账号推送 账号列表推送 所有推送目标都采用相同的 URL 发起请求，URL：https://openapi.xg.qq.com/v3/push/app 所有请求参数通过 JSON 封装上传给后台，后台通过请求参数区分不同的推送目标 Push API 必要参数 推送必要参数指一条推送消息必需携带的参数 参数名 类型 是否必需 描述 audience_type string 是 推送目标all：全量推送tag：标签推送token：单设备推送token_list ：设备列表推送account：单账号推送account_list：账号列表推送 platform string 是 客户端平台类型android：安卓ios：苹果all：安卓&&苹果，仅支持全量推送和标签推送 message object 是 消息体，参见消息体格式 message_type string 是 消息类型notify：通知message：透传消息/静默消息 audience_type：推送目标 推送目标，表示一条推送可以被推送到哪些设备 Push API 提供了多种推送目标的，比如：全量、标签、单设备、设备列表、单账号、账号列表 推送目标 描述 必需参数及使用说明 all 全量推送 无 tag 标签推送 tag_list1. 推送 tag1 和 tag2 的设备 {“tags”:[“tag1”,”tag2”],”op”:”AND”}2. 推送 tag1 或 tag2 的设备 {“tags”:[“tag1”,“tag2”],”op”:“OR”} token 单设备推送 token_list1. 如果该参数包含多个token 只会推送第一个token2. 格式eg：[“token1”] token_list 设备列表群推 token_list1. 最多1000 个token2. 格式eg：[“token1”,”token2”]push_id1. 第一次推送该值填0，系统会创建对应的推送任务，并且返回对应的pushid：1232. 后续推送push_id 填123(同一个文案）表示使用与123 id 对应的文案进行推送 account 单账号推送 account_list1. 该参数有多个账号时，仅推送第一个账号2. 格式eg：[“account1”] account_list 账号列表群推 account_list1. 最多1000 个account2. 格式eg：[“account1”,”account2”]push_id1. 第一次推送该值填0，系统会创建对应的推送任务，并且返回对应的pushid：1232. 后续推送push_id 填123(同一个文案）表示使用与123 id 对应的文案进行推送 全量推送：推送给全部设备 { \"audience_type\": \"all\" } 标签推送：推送给同时设置了\"tag1\"和”tag2“标签的设备 { \"audience_type\": \"tag\", \"tag_list\": { \"tags\": [ \"tag1\", \"tag2\" ], \"op\": \"AND\" } } 单设备推送：推送给token为\"token1\"的设备 { \"audience_type\": \"token\", \"token_list\": [ \"token1\" ] } 设备列表推送，推送给token为\"token1\"和\"token2\"的设备 { \"audience_type\": \"token_list\", \"token_list\": [ \"token1\", \"token2\" ], \"push_id\": \"0\" } 单账号推送：推送给账号为\"account1\"的设备 { \"audience_type\": \"account\", \"account_list\": [ \"account1\" ] } 账号列表推送：推送账号为\"account1\"和\"account2\"的设备 { \"audience_type\": \"account_list\", \"account_list\": [ \"account1\", \"account2\" ], \"push_id\": \"0\" } platform：推送平台 当前支持 Android、iOS 两个平台的推送 其关键字分别为：\"android\", \"ios\"，如果要同时推送两个平台，则关键字为：\"all\" 推送到所有平台： { \"platform\": \"all\" } 推送到安卓平台： { \"platform\": \"android\" } 推送到iOS平台： { \"platform\": \"ios\" } message_type：消息体类型 针对不同平台，消息类型稍有不同，具体参照下表： 消息类型 描述 支持平台 特性说明 notify 通知栏消息 AndroidiOS 通知栏展示消息 message 透传消息/静默消息 Android(透传消息)iOS(静默消息) 通知栏不展示消息 message：消息体 消息体，即下发到客户端的消息 Push API 对 iOS 和 Android 两个平台的消息有不同处理，需要分开来实现对应平台的推送消息，推送的消息体是 JSON 格式 Android普通消息 Android平台具体字段如下表： 字段名 类型 默认值 必需 参数描述 title string 无 是 消息标题 content string 无 是 消息内容 accept_time array 无 否 消息将在哪些时间段允许推送给用户，建议小于10个 n_id int 0 否 通知消息对象的唯一标识1. 大于0，会覆盖先前相同id的消息；2. 等于0，展示本条通知且不影响其他消息；3. 等于-1，将清除先前所有消息，仅展示本条消息 builder_id int 无 是 本地通知样式标识 ring int 1 否 是否有铃声0：没有铃声1：有铃声 ring_raw string 无 否 指定Android工程里raw目录中的铃声文件名，不需要后缀名 vibrate int 1 否 是否使用震动0：没有震动1：有震动 lights int 1 否 是否使用呼吸灯0：使用呼吸灯1：不使用呼吸灯 clearable int 1 否 通知栏是否可清除 icon_type int 0 否 通知栏图标是应用内图标还是上传图标0：应用内图标1：上传图标 icon_res string 无 否 应用内图标文件名或者下载图标的url地址 style_id int 1 否 设置是否覆盖指定编号的通知样式 small_icon string 无 否 消息在状态栏显示的图标，若不设置，则显示应用图标 action JSON 有 否 设置点击通知栏之后的行为，默认为打开app custom_content JSON 无 否 用户自定义的键值对 完整的消息示例如下： { \"title\": \"xxx\", \"content\": \"xxxxxxxxx\", \"accept_time\": [ { \"start\": { \"hour\": \"13\", \"min\": \"00\" }, \"end\": { \"hour\": \"14\", \"min\": \"00\" } }, { \"start\": { \"hour\": \"00\", \"min\": \"00\" }, \"end\": { \"hour\": \"09\", \"min\": \"00\" } } ], \"android\": { \"n_id\": 0, \"builder_id\": 0, \"ring\": 1, \"ring_raw\": \"ring\", \"vibrate\": 1, \"lights\": 1, \"clearable\": 1, \"icon_type\": 0, \"icon_res\": \"xg\", \"style_id\": 1, \"small_icon\": \"xg\", \"action\": { \"action_type \": 1, \"activity\": \"xxx\", \"aty_attr\": { \"if\": 0, \"pf\": 0 }, \"browser\": { \"url\": \"xxxx \", \"confirm\": 1 }, \"intent\": \"xxx\" }, \"custom_content\": { \"key1\": \"value1\", \"key2\": \"value2\" } } } iOS普通消息 iOS平台具体字段如下表： 字段名 类型 默认值 必需 参数描述 aps JSON 无 是 苹果推送服务(APNs)特有的消息体字段其中比较重要的键值对:alert：包含标题和消息内容(必选)badge：App显示的角标数(可选),category：下拉消息时显示的操作标识(可选)详细介绍可以参照：Payload custom string/JSON 无 否 自定义下发的参数 xg string 无 否 系统保留key，应避免使用 完整的消息示例如下： { \"title\": \"xxx\", \"content\": \"xxxxxxxxx\", \"ios\":{ \"aps\": { \"alert\": { \"subtitle\": \"my subtitle\" }, \"badge\": 5, \"category\": \"INVITE_CATEGORY\" }, \"custom1\": \"bar\", \"custom2\": [ \"bang\", \"whiz\" ], \"xg\": \"oops\" } } Android透传消息 透传消息，Android平台特有，即不显示在手机通知栏中的消息，可以用来实现让用户无感知的向App下发带有控制性质的消息 Android平台具体字段如下表： 字段名 类型 默认值 是否必需 参数描述 title string 无 是 消息标题 content string 无 是 消息内容 custom_content JSON 无 否 自定义内容 accept_time array 无 否 消息将在哪些时间段允许推送给用户，建议小于10个 具体完整示例： { \"title\": \"this is title\", \"content\": \"this is content\", \"android\": { \"custom_content\": { \"key1\": \"value1\", \"key2\": \"value2\" } }, \"accept_time\": [ { \"start\": { \"hour\": \"13\", \"min\": \"00\" }, \"end\": { \"hour\": \"14\", \"min\": \"00\" } }, { \"start\": { \"hour\": \"00\", \"min\": \"00\" }, \"end\": { \"hour\": \"09\", \"min\": \"00\" } } ] } iOS静默消息 静默消息，iOS平台特有，类似Android中的透传消息，消息不展示，当静默消息到达终端时，iOS会在后台唤醒App一段时间(小于30s)，让App来处理消息逻辑 具体字段如下表： 字段名 类型 默认值 是否必要 参数描述 aps JSON 无 是 苹果推送服务(APNs)特有的，其中最重要的键值对:content-available：标识消息类型(必须为1)且不能包含alert、sound、badge字段详细介绍可以参照：Payload custom string/JSON 无 否 自定义下发的参数 xg string 无 否 系统保留key，应避免使用 具体完整示例： { \"ios\":{ \"aps\": { \"content-available\": 1 }, \"custom\": { \"key1\": \"value1\", \"key2\": \"value2\" }, \"xg\": \"oops\" } } Push API 可选参数 Push API 可选参数是除了 audience_type、platform、message_type、message 以外，可选的高级参数 参数名 类型 必需 默认值 描述 expire_time int 否 259200 消息离线存储时间（单位为秒）最长存储时间3天，若设置为0，则默认值（3天）建议取值区间[600, 86400x3]第三方通道离线保存消息不同厂商标准不同 send_time string 否 当前系统时间 指定推送时间格式为yyyy-MM-DD HH:MM:SS若小于服务器当前时间，则会立即推送仅全量推送和标签推送支持此字段 multi_pkg bool 否 false 多包名推送当app存在多个不同渠道包（例如应用宝、豌豆荚等），推送时如果是希望手机上安装任何一个渠道的app都能收到消息那么该值需要设置为true loop_times int 否 0 循环任务重复次数仅支持全推、标签推建议取值[1, 15] loop_interval int 否 0 循环执行消息下发的间隔必须配合loop_times使用以天为单位，取值[1, 14]loop_times和loop_interval一起表示消息下发任务的循环规则，不可超过14天 environment string 否 product 用户指定推送环境，仅限iOS平台推送使用product： 推送生产环境dev： 推送开发环境 stat_tag string 否 无 统计标签，用于聚合统计使用场景(示例)：现在有一个活动id：active_picture_123,需要给10000个设备通过单推接口（或者列表推送等推送形式）下发消息，同时设置该字段为active_picture_123推送完成之后可以使用v3统计查询接口，根据该标签active_picture_123 查询这10000个设备的实发、抵达、展示、点击数据 seq int64_t 否 0 接口调用时，在应答包中信鸽会回射该字段，可用于异步请求使用场景：异步服务中可以通过该字段找到server端返回的对应应答包 tag_list object 仅标签推送必需 无 1. 推送 tag1 和 tag2 的设备： {“tags”:[“tag1”,”tag2”],”op”:”AND”}2. 推送 tag1 或 tag2 的设备： {“tags”:[“tag1”,“tag2”],”op”:“OR”} account_list array 单账号推送、账号列表推送时必需 无 若单账号推送1. 要求 audience_type=account2. 参数格式：[“account1”]若账号列表推送1. 参数格式：[“account1”,”account2”]2. 最多1000 个account account_type int 单账号推送时可选 0 1. 账号类型，参考后面账号说明。2. 必须与账号绑定时设定的账号类型一致 token_list array 单设备推送、设备列表推送时必需 无 若单设备推送1. 要求 audience_type=token2. 参数格式：[“token1”]若设备列表推送1. 参数格式：[“token1”,”token2”]2. 最多 1000 个 token push_id string 账号列表推送、设备列表推送时必需 无 账号列表推送和设备列表推送时，第一次推送该值填0，系统会创建对应的推送任务，并且返回对应的pushid：123，后续推送push_id 填123(同一个文案）表示使用与123 id 对应的文案进行推送。(注：文案的有效时间由前面的expire_time 字段决定） Push API 请求完整示例 标签推送请求消息 POST /v3/push/app HTTP/1.1 Host: openapi.xg.qq.com Content-Type: application/json Authorization: Basic YTViNWYwNzFmZjc3YTplYTUxMmViNzcwNGQ1ZmI1YTZhOTM3Y2FmYTcwZTc3MQ== Cache-Control: no-cache Postman-Token: 4b82a159-afdd-4f5c-b459-de978d845d2f { \"platform\": \"android\", \"audience_type\": \"tag\", \"tag_list\": { \"tags\": [ \"tag1\", \"tag2\" ], \"op\": \"AND\" }, \"message_type\": \"notify\", \"message\": { \"title\": \"this is title\", \"content\": \"this is content\", \"custom_content\": { \"key1\": \"value1\", \"key2\": \"value2\" }, \"accept_time\": [ { \"start\": { \"hour\": \"13\", \"min\": \"00\" }, \"end\": { \"hour\": \"14\", \"min\": \"00\" } } ] } } 标签推送应答消息 { \"seq\": 0, \"environment\": \"product\", \"ret_code\": 0, \"push_id\": \"3895624686\" } 账号类型 账号类型是客户端调用SDK接口绑定，类型如下表所示： 账号类型 含义 0 未知 1 手机号 2 邮箱 1000 微信openid 1001 qq openid 1002 新浪微博 1003 支付宝 1004 淘宝 1005 豆瓣 1006 facebook 1007 twitter 1008 google 1009 百度 1010 京东 1011 linkin 1999 其他 2000 游客登录 2001以上 用户自定义 错误码 信鸽REST API接口较多，开发者使用过程中不可避难会遇到各种问题，这里提供了常见的错误码释义，对应着是通用基础返回值中的ret_code字段的可能值 错误码 含义 10100 系统繁忙请稍后重试! 10101 系统繁忙请稍后重试! 10102 缺少参数请检查后重试 10103 参数值非法，请检查后重试 10104 鉴权未通过，请检查secret key! 10105 证书无效! 10106 当前推送类型不支持多平台推送! 10107 消息体是非法json 格式 10108 内部错误,请稍候重试! 10109 内部错误,请稍候重试! 10110 设备未注册! 10111 内部错误,请稍候重试! 10112 内部错误,请稍候重试! 10113 内部错误,请稍候重试! 10114 内部错误,请稍候重试! 10115 帐号不能为空,帐号为空! 10116 帐号不存在 10117 推送内容太大 10201 创建推送任务失败,请稍后重试! 10202 推送消息内容转换APNs 失败! 10203 创建推送任务失败，请稍后重试! 10204 推送失败，请稍后重试! 10205 推送任务过期，请检查！ 10206 获取消息副本失败，请稍后重试！ 10207 获取消息副本失败，请稍后重试！ 10301 帐号列表推送失败，请稍后重试! 10302 帐号列表推送部分失败！ 10303 帐号列表推送全部失败,请稍后重试! 10304 token 列表推送部分失败！ 10305 token 列表推送全部失败,请稍后重试! 10401 内部错误，请稍候重试! 10402 内部错误，请稍候重试! 10403 内部错误，请稍候重试! 10404 内部错误，请稍候重试! 10405 内部错误，请稍候重试! 10406 内部错误，请稍候重试! 10407 内部错误，请稍候重试! 10501 内部错误，请稍候重试! 10502 内部错误，请稍候重试! 10503 内部错误，请稍候重试! 10504 内部错误，请稍候重试! 10505 内部错误，请稍候重试! 10506 内部错误，请稍候重试! 10507 内部错误，请稍候重试! 10601 内部错误，请稍候重试! 10602 内部错误，请稍候重试! 10603 内部错误，请稍候重试! 10604 内部错误，请稍候重试! 10605 内部错误，请稍候重试! 10606 app 未注册，请注册后重试! 10701 内部错误,请稍候重试! 10702 内部错误，请稍候重试! 10707 内部错误，请稍候重试! 10708 内部错误，请稍候重试! 10709 内部错误，请稍候重试! 10710 内部错误，请稍候重试! 10711 内部错误，请稍候重试! 10712 内部错误，请稍候重试! 10713 内部错误，请稍候重试! 其他 未知错误，请稍后重试! "},"push_faq/server_api/other.html":{"url":"push_faq/server_api/other.html","title":"服务端其他语言","keywords":"","body":"服务端其它语言 服务端其它语言SDK及文档官方下载： 1、服务端Java 2、服务端PHP 3、服务端Python 4、服务端C# 另外，感谢第三方开发者（非官方）提供的其它语言版本： 服务端Node js "},"manage.html":{"url":"manage.html","title":"信鸽推送管理台","keywords":"","body":"管理台权限说明 管理台数据展示说明 "},"console/auth.html":{"url":"console/auth.html","title":"管理台权限说明","keywords":"","body":"管理台权限说明 一、角色分类&概述 1.管理员 定位：应用创建者、项目负责人、团队leader、开发等概述：拥有全平台权限，管理员有权删除应用，添加/删除/编辑其它角色，管理员之间可以互删等 2.运营人员 定位：平台的使用者、负责推送消息的成员概述：该角色可以推送消息、查看数据，但不能删除应用，不能添加/编辑/删除权限角色，也不能查看ACCESS KEY /SECRET KEY 3.查看人员 定位：平台数据的查看者，如：实习生、外包成员等概述：该角色仅具备查看数据的权限，不能创建推送，不能删除应用，不能添加修改权限角色等 二、角色权限说明 各角色具体权限明细如下： "},"console/pushdetail.html":{"url":"console/pushdetail.html","title":"管理台数据展示说明","keywords":"","body":"推送详情 功能简介 推送详情功能帮助您在创建推送后，及时了解任务下发的进度&时间，推送转化率，覆盖面，以及推送时效性。当前支持对全量用户推送，标签推送的数据分析。 界面介绍 下发进度 对任务下发进行的实时统计，当任务开始下发后进行刷新。 推送转化分析 对于推送转化率的分析，可以分为Android和iOS两个平台。 [Android推送] 计划发送：当前应用30天内和服务器建立过连接的设备量 设备在线：在推送有效期内，和服务器进行了连接的设备数量（只有设备和服务器建立连接，消息才能被正常推出）到达：指到达终端设备中的消息Service数量展现：调用系统的消息展示接口，对消息进行展示的数量点击：点击通知栏消息的数量 [iOS推送] 计划推送：系统中所有有效设备的数量（当APNs返回Token无效时，系统会每天对这些无效设备进行清理）服务器下发：信鸽服务器真实下发的消息的设备数量APNs接收：APNs（苹果推送消息服务器）返回的收到消息的谁被数量\u0010点击：点击通知栏推送消息的数量 覆盖面分析 覆盖面分析，通过对推送到达量以及App活跃数量进行对比，衡量全量推送的覆盖面。（当前暂时只支持Android推送） 当日活跃覆盖率：推送任务的到达量/推送当日的DAU3日活跃覆盖率：推送任务的到达量/推送近三日的去重DAU 推送时效分析 推送时效分析，将推送统计按照时间维度进行细分，支持分钟颗粒度以及小时颗粒度，最大支持24的分时统计 "},"sdk_update.html":{"url":"sdk_update.html","title":"最近更新","keywords":"","body":"最近更新 Android SDK更新说明 Android SDK v3.2.3 更新时间 2018-5-4 版本更新说明 优化网络连接，增强稳定性 解决部分设备点击通知无法跳转指定页面问题 解决部分机型Android 8.0无法弹出通知问题 其他常见问题修复 升级提示 建议升级！ 下载地址： Android SDK v3.2.3 Android SDK v3.2.4（beta） 更新时间 2018-5-4 版本更新说明 修复偶现的10103问题 统一小米、魅族、华为通道receiver（用户无须再针对每个厂商通道，自行开发receiver，方便用户使用） FCM版本升级及crash修复 支持厂商通道展示、点击数据上报（目前还未充分与后台联调数据，下周还会持续验证数据） 升级提示 建议升级！ 下载地址： Android SDK v3.2.4（beta） iOS SDK 更新说明 iOS SDK v3.1.0 更新时间 2018-4-11 版本更新说明 增加消息回执统计SDK(iOS 10+) 自动化Device Token上报 升级提示 建议升级！ 下载地址： iOS SDK v3.1.0 iOS SDK v3.1.1(beta) 更新时间 2018-5-3 版本更新说明 更新账号注册、解绑协议（修复老版本账号注册、解绑不可用问题） 去除模拟器支持 绑定接口问题修复 注销接口问题修复 升级提示 建议升级！ 下载地址： iOS SDK v3.1.1(beta) "},"push_faq/noun_explanation.html":{"url":"push_faq/noun_explanation.html","title":"名词解释","keywords":"","body":"指标名词解释 应用列表 昨日连接设备：昨日有成功连接过信鸽服务器的设备数。 昨日卸载设备：昨日该应用被卸载的设备总数。信鸽可以统计到应用被卸载的动作，卸载一次上报一次，因此这里设备数未去重。 有效设备：当前处于注册状态（在信鸽注册成功）的设备数。 应用配置 应用包名：出于安全考虑，应用包名填写后不可更改；填写应用包名才能进行推送操作；应用包名是应用的Package Name，用于AndroidManifest.xml配置，比如com.tencent.news。 管理员：所有管理员权限一致，可以删除其他管理员但不可以删除自己。如果要转让管理员，建议先添加一个新的管理员，然后用新的管理员账号删除掉旧的账号以完成转让。 测试设备：测试设备用于推送消息之前先进行特定设备推送，以测试实际情况，确定无误之后再正式推送。测试设备的ID就是DeviceToken，通过logcat获取，具体请查阅开发者手册。 ACCESS KEY：客户端鉴权密钥，与Access ID共同验证以确定调用合法；需要配置到客户端SDK中，无法更换。 SECRET KEY：用于验证API调用，与APPKEY共同验证以确定调用合法。如果泄露，需要立即更换并重新配置客户端SDK。 ACCESS ID：识别一个应用的唯一标识，不能更改，需要配置到客户端SDK中，调用后台接口时也需要提供。 创建推送 推送内容：消息命令是应用接收后去执行的代码，具体代码形式由应用开发者自己定义。利用消息命令，可以远程控制应用各种行为，比如：应用下载并更换启动闪屏；修改移动游戏中物品的价格；静默更新应用内文字或者图片内容。 立即/定时推送：立即推送多适用于测试推送。定时推送多用于正式对外推送。 自定义参数：您还可以自定义设置键值对(key-value)，根据不同的键值对实现自定义需求。 离线保存：用户如果不在线，下次上线时可以收到推送，这里需要设定一个离线保存过期的时间，超过这个时间如果用户仍不在线，则不会收到这条推送。如果没有限时活动，强烈建议保存72小时！！！ 时段控制：设定用户可以接收推送的时段，您可以避免在夜间打扰用户，也可以设定在特定时间用户才能收到推送。 点击通知操作：设定用户点击通知之后的响应动作，可以直接打开应用，也可以指定打开应用的某个功能页面，还可以使用浏览器打开一个网址。 多包名推送：在多包名提示模式下，设备上所有使用这个access_id注册推送的app都会收到消息。该功能使用与区分不同渠道和包名的app。 推送列表 推送列表：展示的数据是全量/批量推送（属于广播类），点对点（单播类）推送不会展示在推送列表内。查看单播类推送，请前往“推送数据”页面。 推送时间：开始本条推送的时间。 Android-有效推送量：是指发送给当前在线设备（与服务器有连接的设备）的推送量。若消息设置了离线保存，随着时间的推移和用户的上线动作，有效推送量会有数值上的增加，即表示新上线的用户也收到了该条推送。 iOS-有效推送量：是指成功发送给苹果服务器的推送量。信鸽负责将消息成功推送给苹果服务器，但由于苹果服务器限制，抵达量无法统计。 抵达量：本条推送成功推送的用户数，实时数据有5分钟左右延迟。 撤销定时：撤销已经设定的，尚未发生的定时推送，撤消后该条推送将不再执行。 删除离线：是指删除后台存储的，即将发送的离线消息。成功删除离线消息后，这部分消息将不再发送。但是！！已经发送成功的消息不能进行删除。 推送数据 Android-有效推送量：是指发送给当前在线设备（与服务器有连接的设备）的推送量。若消息设置了离线保存，随着时间的推移和用户的上线动作，有效推送量会有数值上的增加，即表示新上线的用户也收到了该条推送。 iOS-有效推送量：是指成功发送给苹果服务器的推送量。信鸽负责将消息成功推送给苹果服务器，但由于苹果服务器限制，抵达量无法统计。 抵达量：本条推送成功推送的用户数，实时数据有5分钟左右延迟。 抵达率：抵达量/推送量×100% 点击量：成功的推送中，本条推送消息被点击次数的总计，点击量要求终端调用特定函数上报。 点击率：点击量/抵达量×100% 基础数据 日新增设备数：当天新注册的设备总数，需集成客户端SDK版本V2.3.6及以上 日卸载设备数：当天卸载应用的设备总数，需要集成客户端SDK版本V2.3.6及以上 日连接设备数：当天连接过信鸽服务器的设备总数 我的标签 标签：通常是指给某个或某一群用户打上标签。自定义标签可以通过客户端或服务端调用进行设置，之后在前台进行使用。 高级数据标签：是指信鸽通过数据整理，直接为特定用户打上标签。高级标签仅供使用，无法编辑或删除。 "},"technical_support.html":{"url":"technical_support.html","title":"技术支持","keywords":"","body":"技术支持 人工客服 工作时间：周一至周五 09：30-12：00，14：00-18：00 (法定假期除外) 人工客服入口： BUG类问题反馈 产品性能或BUG反馈请在问题反馈页面中填写详细信息，我们会在24小时内回复您 问题反馈入口 商务咨询: data@tencent.com "}}