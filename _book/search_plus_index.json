{"./":{"url":"./","title":"信鸽基础介绍","keywords":"","body":"信鸽基础介绍 平台简介 信鸽（XG Push）是一款专业的移动App推送平台，支持百亿级的通知/消息推送，秒级触达移动用户，现已全面支持Android和iOS两大主流平台。 开发者可以方便地通过嵌入SDK，通过API调用或者Web端可视化操作，实现对特定用户推送，大幅提升用户活跃度，有效唤醒沉睡用户，并实时查看推送效果。 推送场景定义 推送通知 在信鸽产品中，通知定义为Android和iOS开发者指南中的Notification。服务器定向将信息实时送达手机，通过建立一条手机与服务器的连接链路，当有消息需要发送到手机时，通过此链路发送即可。 通过推送一条用户可见的信息，引导用户进行有目的性的操作。通常用于产品信息知会、新闻推送和个性化消息等场景。 本地通知 本地通知定义为Android开发者指南中的Local Notification。 应用通过自定义的日期、时间和消息内容，无需通过服务器即可向用户推送一条可见的信息。通常用于应用的某些本地定时提醒场景，游戏应用中建筑物升级结束的提醒，以及一些有明确结束时间的场景等。 更多请参考XGPushManager提供信鸽服务的对外API列表 应用内消息 在信鸽产品中，我们支持通过推送可执行代码指令，让应用在后台进行一系列操作行为，通过此功能，可以用最小成本实现对应用的远程操控，推送的应用内消息内容由各个应用开发者自定义。消息不弹出通知栏。 应用内消息可以支持的场景非常广泛，可以任由开发人员扩展。 例如给部分标签用户进行消息命令推送，让应用在WIFI情况下自动下载安装包并静默升级至最新；快速增量更新应用，或让应用根据自身情况下载并静默增量更新，对于不需要更新的用户不造成干扰。 另外，应用内消息既可以展示在通知栏里，也可以直接做成app的消息中心，所以自由度比推送通知栏消息高出百倍。 标签 在信鸽产品中，标签通常是指给某个一群用户打上标签，例如在北京的喜爱美食的使用iOS的用户；超过30天未启动应用的沉睡用户；高消费潜力用户；团队测试用户等。 一个应用最多有10000个 标签（tag）， 每个token在一个应用下最多100个 标签（tag）， 标签（tag）中不准包含空格。 地理标签、应用版本、流失用户这三个标签，是信鸽默认提供的，可以直接使用。 账号 在信鸽产品中，别名/帐号通常是指给某特定用户推送消息。别名/帐号可以是终端在注册时上报的QQ号、openid、邮箱帐号、手机号等。 这里强调，若希望推送帐号，必须首先将账号与token进行绑定，否则将无法推送成功。绑定方式见Android、iOS接入指南——根据帐号推送。 常见问题 Q1:iOS SDK中有没有使用热更新或者私有接口？ A:信鸽SDK没有使用过热更新或私有接口，不会影响苹果审核。 Q2:推送数量/推送频率限制？ A:推送数量无限制。推送频率上，仅全量广播限频为每3秒一次，其他推送行为不限频。 Q3:对单个设备，保存多少条离线信息？保存时间？ A:离线消息Android最多保存2条，iOS最多保存1条；保存时间最多72小时。 Q4:标签方面限制？ A:单个设备最多设置100个标签，单个app全局最多可以有10000个不同的标签。 Q5:信鸽与腾讯开放平台的APPID数据是否相通？ A:当你在开放平台注册应用并使用信鸽后，应用的信息会自动从开放平台同步至信鸽平台，单独使用信鸽时不用重新接入应用。但是，在信鸽接入的应用不会同步至开放平台。 Q6:当第一次注册成功后，没有反注册，以后使用还需要注册吗？ A:不需要，只要没反注册，就不需要再次注册 Q7:应用关闭或结束进程后，还能收到推送消息吗？ A:信鸽推送主要依赖信鸽的service进行消息的收发，杀死进程之后信鸽service也被杀死，只能等待service被拉活或重启app才可以收到推送。若手机中有其他接入信鸽的app被打开，则可以利用其他app的service接收消息，但共享service通道也受手机ROM限制，无法保证百分之百的成功率。 Q8:设备注册为什么收不到回调信息？ A:注册操作中，后台只可能有三种出错行为： (1)不响应； (2)返回错误格式的数据包； (3)返回错误码。这三种行为终端应该都可以检测到并给出回调。 Q9:为什么我推送成功了，有了抵达量，点击量却等于0？ iOS点击量统计需要调用特殊代码，具体请参考iOS开发文档。 Q10:为什么会出现推送通知时，只有声音却没有文字信息的情况？ A:该问题与系统有很大关系，需要拿设备的logcat来进行特定分析。 Q11:token与Account区别？ A:token是一台设备（device）的标识，账号是一个用户（users）的标识。一个token只能绑定一个账号，多次绑定时，以最后一次为准。 Q12:账号在设备A上登录过，又在设备B上登录？给这个账号发信息会怎么样？ A:设备B上能够收到推送。设备A无法收到推送。 Q13:标签与账号的区别？ A:标签是用于标识一个token或用户的一些属性，如广东省、男性、游戏玩家等。帐号是用户的账号，请勿用标签作为别名使用。 Q14:在应用列表中看到“覆盖设备数”，具体指的是什么？ A:是指该应用下处于注册状态的设备数/终端数，同时也是该应用在推送时可以覆盖到的最大设备数。终端若调用了unregister的接口，覆盖设备数会减少。 Q15:为什么在web端推送出现服务器繁忙？ A: 请先检查token以及所选推送环境是否正确，然后检查证书是否正确提交，若还出现相同错误可重新制作一份不带密码的证书提交再试。 Q16:推送过程中，非定时推送（立即推送）能否撤销？ A:不能，只有返回push_id的任务才可以做撤销操作。 Q17:推送后查看推送列表，已经推送完成了，状态却显示推送中，怎么办？ A:刷新再试试。 Q18:在推送时，如何向单个用户推送消息？ A:请参考开发手册，有关于“推送消息给单个设备”和“推送消息给单个账户或别名”的使用指南。 Q19:用户重连上线后收到多条push的顺序是怎样？ A:按照消息ID递增。客户端也是按照此规则收取消息，因此，收消息的顺序就是发消息的顺序。 Q20:我现在有安卓的用户和iOS的用户，那我php后台要写两个不同的接口分别推给安卓用户和ios用户吗？ A:需要调用两次推送接口 也可以把两个封装为一个。 Q21:如果定时push选择的是过去的时间，是不是不会push出去？ A:不是，选择过去的时间系统则会立刻发送。 Q22:在信鸽管理台中创建token单推之后，历史明细中为什么没有推送记录？ A:信鸽管理台中的推送历史明细只展示全量推送、标签推送和官网的号码包推送，不能展示单个token或者账号推送。 "},"android_access.html":{"url":"android_access.html","title":"Android接入","keywords":"","body":"Android接入 在Android接入部分，为开发者提供了快速接入指南、完整接入指南以及3.1版本升级指南。如果开发者想快速实现推送功能集成，可参考快速接入指南；如果想集成多场景推送功能，请参考完整接入指南 Android SDK API Android SDK 3.X升级指南 Android SDK 集成指南 "},"android_access/api.html":{"url":"android_access/api.html","title":"Android SDK API","keywords":"","body":"API接口 接口概览 所有API接口的包名路径前缀都是：com.tencent.android.tpush，其中有以下个重要的对外提供接口的类，如下： 类名 说明 XGPushManagerPush服务 推送 XGPushConfig Push服务配置项接口 XGPushBaseReceiver 接收消息和结果反馈的receiver，需要开发者自己在AndroidManifest.xml静态注册 XGPushManager功能类 XGPushManager提供信鸽服务的对外API列表，方法默认为public static类型。 原型 功能 void registerPush(Context context)； 启动并注册（无注册回调） void registerPush(Context context, final XGIOperateCallback callback) 启动并注册（有注册回调） void registerPush(Context context, String account, XGIOperateCallback callback) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2不包括3.2.2之前的版本使用，有注册回调） void bindAccount(Context context, String account, XGIOperateCallback callback) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口会覆盖设备之前绑定过的账号，仅当前注册的账号生效） void bindAccount(Context context, final String account) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口会覆盖设备之前绑定过的账号，仅当前注册的账号生效，无注册回调） void appendAccount(Context context, String account, XGIOperateCallback callback) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口保留之前的账号，只做增加操作，一个token下最多只能有3个账号超过限制会自动顶掉之前绑定的账号，有注册回调） void appendAccount(Context context, final String account) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口保留之前的账号，只做增加操作，一个token下最多只能有3个账号超过限制会自动顶掉之前绑定的账号，无注册回调） void delAccount(Context context, final String account, XGIOperateCallback callback) 解绑指定账号（3.2.2以及3.2.2之后的版本使用，有注册回调） void delAccount(Context context, final String account ） 解绑指定账号（3.2.2以及3.2.2之后的版本使用，无注册回调） void registerPush(Context context,String account, String ticket, int ticketType, String qua, final XGIOperateCallback callback) 同上，仅供带登陆态的业务使用 void unregisterPush(Context context) 反注册，建议在不需要接收推送的时候调用 void setTag(Context context,String tagName) 设置标签 void deleteTag(Context context,String tagName) 删除标签 XGPushClickedResult onActivityStarted(Activity activity) Activity被打开的效果统计；获取下发的自定义key-value void onActivityStoped(Activity activity) Activity被打开的效果统计 void setPushNotificationBuilder(Context context, int notificationBulderId, XGPushNotificationBuilder notificationBuilder) 自定义本地通知样式 long addLocalNotification(Context context, XGLocalMessage msg) 本地通知 boolean isNotificationOpened(Context context) 检测通知栏是否关闭 XGPushConfig配置类 XGPushConfig提供信鸽服务的对外配置API列表，方法默认为public static类型，对于本类提供的set和enable方法，要在XGPushManager接口前调用才能及时生效。 原型 功能 void enableDebug(Context context,boolean debugMode) 是否开启debug模式，即输出logcat日志重要：为保证数据的安全性，发布前必须设置为false） boolean setAccessId(Context context,long accessId) 配置accessId boolean setAccessKey(Context context,String accessKey) 配置accessKey String getToken(Context context) 获取设备的token，只有注册成功才能获取到正常的结果 void setReportNotificationStatusEnable(final Context context,final boolean debugMode) 设置上报通知栏是否关闭 默认打开 void setReportApplistEnable(final Context context,final boolean debugMode) 设置上报APP 列表，用于智能推送 默认打开 XGPushBaseReceiver广播类 XGPushBaseReceiver类提供透传消息的接收和操作结果的反馈，需要开发者继承本类，并重载相关的方法； 同时，还需要在AndroidManifest.xml静态注册（注意：如果是在代码动态注册，只有当前APP运行时才能收到消息）。 原型 功能 void onTextMessage(Context context,XGPushTextMessage message) 应用内消息的回调 void onRegisterResult(Context context,int errorCode,XGPushRegisterResult registerMessage) 注册回调 void onUnregisterResult(Context context, int errorCode) 反注册回调 void onSetTagResult(Context context,int errorCode,String tagName) 设置标签回调 void onDeleteTagResult(Context context, int errorCode,String tagName) 删除标签回调 void onNotifactionShowedResult(Context context, XGPushShowedResult notifiShowedRlt) 通知被展示触发的回调，可以在此保存APP收到的通知 void onNotifactionClickedResult(Context context, XGPushClickedResult message) 通知被点击触发的回调 启动与注册 APP只有在完成信鸽的启动与注册后才可以信鸽SDK提供push服务，在这之前请确保配置AccessId和AccessKey。 新版的SDK已经将启动信鸽和APP注册统一集成在注册接口中，即只需调用注册接口便默认完成启动和注册操作。 注册成功后，会返回设备token，token用于标识设备唯一性，同时也是信鸽维持与后台连接的唯一身份标识。关于如何获取token请参考“获取token”章节。 注册接口通常提供简版和带callback版本的接口，请根据业务需要决定选择接口。 绑定设备注册 普通注册只注册当前设备，后台能够针对不同的设备token发送推送消息，有2个版本的API接口。 注意：这种注册方式，不支持推送帐号。 （1）原型 public static void registerPush(Context context) （2）参数 context：当前应用上下文对象，不能为null （3）示例 XGPushManager.registerPush(this); 另外，为方便用户获取注册是否成功的状态，提供带callback的版本。 （1）原型 public static void registerPush(Context context, final XGIOperateCallback callback) （2）参数 context：当前应用上下文对象，不能为null callback：callback调用，主要包括操作成功和失败的回调，不能为null （3）示例 XGPushManager.registerPush(this, new XGIOperateCallback() { @Override public void onSuccess(Object data, int flag) { Log.d(\"TPush\", \"注册成功，设备token为：\" + data); } @Override public void onFail(Object data, int errCode, String msg) { Log.d(\"TPush\", \"注册失败，错误码：\" + errCode + \",错误信息：\" + msg); } }) 绑定账号注册 绑定账号注册指的是，在绑定设备注册的基础上，使用指定的账号（一个账号不能在多个设备登陆）注册APP，这样可以通过后台向指定的账号发送推送消息，有2个版本的API接口。 注意：这里的帐号可以是邮箱、QQ号、手机号、用户名等任意类别的业务帐号。 （1）原型 public static void registerPush(Context context, String account) （2）参数 context：当前应用上下文对象，不能为null account：绑定的账号，绑定后可以针对账号发送推送消息，account不能为单个字符如“2”，“a”。 如果要按别名推送，那就需要开发者在调用注册接口时把别名设置在注册请求里面的account字段，一台设备只允许有一个帐号别名。 （3）示例 XGPushManager.registerPush(this, \"UserAccount\") 另外，为方便用户获取注册是否成功的状态，提供带callback的版本。 （1）原型 public static void registerPush(Context context, String account, final XGIOperateCallback callback) （2）参数 context：当前应用上下文对象，不能为null account：绑定的账号，绑定后可以针对账号发送推送消息。 如果要按别名推送，那就需要开发者在调用注册接口时把别名设置在注册请求里面的account字段，一台设备只允许有一个别名，多个设备登录同一个账号最后一个绑定的设备有效，不能为null callback：callback调用，主要包括操作成功和失败的回调，不能为null 注：在信鸽3.2.2beta版本以后账号绑定需要调用全新的接口 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2不包括3.2.2之前的版本使用，有注册回调 void registerPush(Context context, String account, XGIOperateCallback callback) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口会覆盖设备之前绑定过的账号，仅当前注册的账号生效） void bindAccount(Context context, String account, XGIOperateCallback callback) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口会覆盖设备之前绑定过的账号，仅当前注册的账号生效，无注册回调） void bindAccount(Context context, final String account) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口保留之前的账号，只做增加操作，一个token下最多只能有3个账号超过限制会自动顶掉之前绑定的账号，有注册回调） void appendAccount(Context context, String account, XGIOperateCallback callback) 启动并注册APP，同时绑定账号,推荐有帐号体系的APP使用（3.2.2以及3.2.2之后的版本使用，此接口保留之前的账号，只做增加操作，一个token下最多只能有3个账号超过限制会自动顶掉之前绑定的账号，无注册回调） void appendAccount(Context context, final String account) （3）示例 XGPushManager.registerPush(this, \"UserAccount\", new XGIOperateCallback() { @Override public void onSuccess(Object data, int flag) { Log.d(\"TPush\", \"注册成功，设备token为：\" + data); } @Override public void onFail(Object data, int errCode, String msg) { Log.d(\"TPush\", \"注册失败，错误码：\" + errCode + \",错误信息：\" + msg); } }); 账号解绑 若APP调用registerPush(context, account)等绑定account账号，需要解绑（如用户退出），可以调用以下方法。 调用 registerPush(context, \"*\")或registerPush(context, \"*\", xGIOperateCallback ) 即设置account=\"*\"即为解除之前的账号绑定 在信鸽3.2.2版本以后解绑账号需要调用全新的接口： //解绑指定账号（3.2.2以及3.2.2之后的版本使用，有注册回调） void delAccount(Context context, final String account, XGIOperateCallback callback) //解绑指定账号（3.2.2以及3.2.2之后的版本使用，无注册回调） void delAccount(Context context, final String account ） 注意 账号解绑只是解除token与APP账号的关联，若使用全量/标签/token推送仍然能收到通知/消息。 带登陆态的注册 考虑到用户的登陆态问题，比如手机QQ或QZone业务场景，我们提供了带登陆态的注册接口，方便适用该类业务的使用。 （1）原型 public static void registerPush(Context context, String account, String ticket, int ticketType, String qua, final XGIOperateCallback callback) ***（2）参数 *** context：当前应用上下文对象，不能为null callback：操作回调，主要包括操作成功和失败的回调，不能为null account：绑定的账号，绑定后可以针对账号发送推送消息。 如果要按别名推送，那就需要开发者在调用注册接口时把别名设置在注册请求里面的account字段，一台设备只允许有一个别名，但一个别名下可以有15台设备，不能为null ticket：登陆态票据，不能为null ticketType：票据类型 qua：QZone专用字段，不需要时可填null ***（3）示例** ```java XGPushManager.registerPush(this, \"UserAccount\", \"ticket\", 1, null, new XGIOperateCallback() { @Override public void onSuccess(Object data, int flag) { Log.d(\"TPush\", \"注册成功，设备token为：\" + data); } @Override public void onFail(Object data, int errCode, String msg) { Log.d(\"TPush\", \"注册失败，错误码：\" + errCode + \",错误信息：\" + msg); } }); 获取注册结果 有2种途径可以获取注册是否成功。 （1） 使用callback版本的注册接口 XGIOperateCallback类提供注册成功或失败的处理接口，请参考注册接口里面的示例。 XGIOperateCallback的定义： /** * 操作回调接口 */ public interface XGIOperateCallback { /** * 操作成功时的回调。 * @param data 操作成功的业务数据，如注册成功时的token信息等。 * @param flag 标记码 */ public void onSuccess(Object data, int flag); /** * 操作失败时的回调 * @param data 操作失败的业务数据 * @param errCode 错误码 * @param msg 错误信息 */ public void onFail(Object data, int errCode, String msg); } （2）重载XGPushBaseReceiver 可通过重载XGPushBaseReceiver的onRegisterResult方法获取。 （注意：重载的XGPushBaseReceiver需要配置在AndroidManifest.xml，请参考“消息配置”章节的相关内容） 示例 /** * 注册结果 * * @param context * APP上下文对象 * @param errorCode * 错误码，{@link XGPushBaseReceiver#SUCCESS}表示成功，其它表示失败 * @param registerMessage * 注册结果返回 */ 其中，XGPushRegisterResult提供的方法列表： 方法名 返回值 默认值 描述 getToken() String \"\" 设备的token，即设备唯一识别ID getAccessId() long 0 获取注册的accessId getAccount String \"\" 获取注册绑定的账号 getTicket() String \"\" 登陆态票据 getTicketType() short 0 票据类型 反注册 当用户已退出或APP被关闭，不再需要接收推送时，可以取消注册APP，即反注册。（注意一旦设备反注册，直到这个设备重新注册成功这个期间内，下发的消息该设备都无法收到) （1）原型 public static void unregisterPush(Context context) （2）参数 context： APP的上下文对象。 （3）示例 XGPushManager.unregisterPush(this); 反注册结果 可通过重载XGPushBaseReceiver的onUnregisterResult方法获取。 示例 /** * 反注册结果 * * @param context * APP上下文对象 * @param errorCode * 错误码，{@link XGPushBaseReceiver#SUCCESS}表示成功，其它表示失败 */ @Override public void onUnregisterResult(Context context, int errorCode) { } 注意 反注册操作切勿过于频繁，可能会造成后台同步延时。 切换帐号无需反注册，多次注册自动会以最后一次为准。 通知和消息 信鸽推送服务主要提供2种推送格式： “推送通知” 和 “透传消息命令”，二者存在一定的区别。 推送通知（展现在通知栏） 指的是在设备的通知栏展示的内容，由信鸽SDK完成所有的操作，APP可以监听通知被打开的行为，也就是说在前台下发的通知不需要APP做任何处理，默认会展示在通知栏。 成功注册信鸽服务后，通常不需要任何设置便可下发通知。 通常来说，结合自定义通知样式，常规的通知能够满足大部分业务需求，如果需要更灵活的方式请考虑使用消息。 应用内消息命令（消息不展示到通知栏） 指的是由信鸽下发给APP的内容，需要APP继承XGPushBaseReceiver接口实现并自主处理所有操作过程，也就是说，下发的消息默认是不会展示在通知栏的，信鸽只负责将消息从信鸽服务器下发到APP这个过程，不负责消息的处理逻辑，需要APP自己实现。具体可参考Demo中MessageReceiver。 消息指的是由开发者通过前台或后台脚本下发的文本消息，信鸽只负责将消息传递给APP，APP完全自主负责消息体的处理。 消息具有灵活性强和高度定制性特点，因此更适合APP自主处理个性化业务需求，比如下发APP配置信息、自定义处理消息的存储和展示等。 例如：某游戏需要针对不同情景（用户升级提示、版本更新提示、活动营销提示等）提供不同的通知，可以把这些情景以json格式封装在消息，下发到APP，然后APP根据这些场景提供不同的提示，满足个性化需求。 消息配置 若要接收消息，需要配置消息接收Receiver，即在AndroidManifest.xml配置以下信息，其中android:name的值需要修改为APP自己实现的Receiver。 获取应用内消息 开发者在前台下发消息，需要APP继承XGPushBaseReceiver重载onTextMessage方法接收，成功接收后，再根据特有业务场景进行处理。 同时，XGPushBaseReceiver还提供其它相关的接口，如通知被展示、被点击的结果反馈、注册/反注册结果反馈等，请参考“XGPushBaseReceiver”章节或demo中的MessageReceiver类。 请确保在AndroidManifest.xml已经注册过该receiver，即设YOUR_PACKAGE.XGPushBaseReceiver。 原型 public void onTextMessage(Context context, XGPushTextMessage message) 参数 context：应用当前上下文 message：接收到消息结构体，其中XGPushTextMessage的方法列表如下： 方法名 返回值 默认值 描述 etContent() String \"\" 消息正文内容，通常只需要下发本字段即可 getCustomContent() String \"\" 消息自定义key-value getTitle() String \"\" 消息标题（注意：从前台下发应用内消息字中的描述不属于标题 本地通知 本地通知由用户自定义设置，保存在本地。当应用打开，信鸽service 会根据网络心跳判断当前是否有通知5分钟一次 本地通知需要service开启才能弹出，可能存在5分钟左右延时。（当设置的时间小于当前设备时间通知弹出。） ```java //新建本地通知 XGLocalMessage local_msg = new XGLocalMessage(); //设置本地消息类型，1:通知，2:消息 local_msg.setType(1); // 设置消息标题 local_msg.setTitle(\"qq\"); //设置消息内容 local_msg.setContent(\"ww\"); //设置消息日期，格式为：20140502 local_msg.setDate(\"20140930\"); //设置消息触发的小时(24小时制)，例如：22代表晚上10点 local_msg.setHour(\"19\"); //获取消息触发的分钟，例如：05代表05分 local_msg.setMin(\"31\"); //设置消息样式，默认为0或不设置 local_msg.setBuilderId(0); //设置动作类型：1打开activity或app本身，2打开浏览器，3打开Intent ，4通过包名打开应用 local_msg.setAction_type(1); //设置拉起应用页面 local_msg.setActivity(\"com.qq.xgdemo.SettingActivity\"); // 设置URL local_msg.setUrl(\"http://www.baidu.com\"); // 设置Intent local_msg.setIntent(\"intent:10086#Intent;scheme=tel;action=android.intent.action.DIAL;S.key=value;end\"); // 是否覆盖原先build_id的保存设置。1覆盖，0不覆盖 local_msg.setStyle_id(1); // 设置音频资源 local_msg.setRing_raw(\"mm\"); // 设置key,value HashMap map = new HashMap(); map.put(\"key\", \"v1\"); map.put(\"key2\", \"v2\"); local_msg.setCustomContent(map); // 设置下载应用URL local_msg.setPackageDownloadUrl(\"http://softfile.3g.qq.com:8080/msoft/179/1105/10753/MobileQQ1.0(Android)_Build0198.apk\"); //添加通知到本地 XGPushManager.addLocalNotification(context,local_msg); ``` 自定义通知样式 用户可以根据自行需要设置通知样式，由于目前的定制ROM的限制，部分接口 无法适配全部机型。 XGCustomPushNotificationBuilder build = new XGCustomPushNotificationBuilder(); build.setSound( RingtoneManager.getActualDefaultRingtoneUri( getApplicationContext(), RingtoneManager.TYPE_ALARM)) .setDefaults(Notification.DEFAULT_VIBRATE) // 振动 .setFlags(Notification.FLAG_NO_CLEAR); // 是否可清除 // 设置自定义通知layout,通知背景等可以在layout里设置 build.setLayoutId(R.layout.notification); // 设置自定义通知内容id build.setLayoutTextId(R.id.content); // 设置自定义通知标题id build.setLayoutTitleId(R.id.title); // 设置自定义通知图片资源 build.setLayoutIconDrawableId(R.drawable.logo); // 设置状态栏的通知小图标 build.setIcon(R.drawable.right); // 设置时间id build.setLayoutTimeId(R.id.time); // 若不设定以上自定义layout，又想简单指定通知栏图片资源 build.setNotificationLargeIcon(R.drawable.ic_action_search); // 客户端保存build_id XGPushManager.setPushNotificationBuilder(this, build_id, build); 获取设备Token Token是信鸽保持与后台长连接的唯一身份标识，是识别识别的唯一ID，只有设备注册成功后才能获取token，可以有以下方法获。（信鸽的token在应用卸载重新安装的时候有可能会变。） （1）通过带callback的注册接口获取 带XGIOperateCallback的注册接口的onSuccess(Object data, int flag)方法中，参数data便是token，具体可参考注册接口的相关示例。 （2）重载XGPushBaseReceiver 重载XGPushBaseReceiver的onRegisterResult (Context context, int errorCode, XGPushRegisterResult registerMessage)方法，通过参数registerMessage提供的getToken接口获取，具体可参考“获取注册结果”章节。 （3） XGPushConfig.getToken(context) 当设备一旦注册成功后，便会将token存储在本地，之后可通过XGPushConfig.getToken(context)接口获取。 获取通知 通知的下发和展示完全是由信鸽SDK控制的，但有的开发者需要在本地存储被展示过的通知内容，可以通过重载XGPushBaseReceiver的onNotificationShowedResult(Context, XGPushShowedResult)方法实现。其中，XGPushShowedResult对象提供读取通知内容的接口。 原型 public abstract void onNotificationShowedResult(Context context,XGPushShowedResult notifiShowedRlt); 参数 context：当前应用上下文 notifiShowedRlt： 被展示的通知对象 获取消息点击结果 【2.30及以上版本】通知效果监听和自定义key-value 使用信鸽SDK内置的activity展示页面，默认已经统计通知/消息的抵达量、通知的点击和清除动作。但如果开发者要监听这些事件，需要按照以下方法嵌入代码。 注意：如果需要统计由信鸽推送引起的打开APP操作或获取下发的自定义key-value，需要开发者在所有（或被打开）的Activity的onResume()调用以下方法。 （1）原型 public abstract void onNotificationShowedResult(Context context,XGPushShowedResult notifiShowedRlt); （2）参数 activity：被打开activity上下文 （3）返回值 XGPushClickedResult：通知被打开的对象，如果该activity是由信鸽的通知引起打开动作的，返回XGPushClickedResult，否则返回null。 XGPushClickedResult类方法列表： 方法名 返回值 默认值 描述 getMsgId() long 0 消息id getTitle() String \"\" 通知标题 getContent() String \"\" 通知正文内容 getActivityName() String \"\" 被打开的页面名称 getCustomContent() String \"\" 自定义key-value，json字符串同时，在Activity的onPause()调用以下方法 （1）原型 public static void onActivityStoped(Activity activity) （2）参数 activity：当前activity上下文 （3）示例 @Override protected void onPause() { super.onPause(); XGPushClickedResult clickedResult = XGPushManager.onActivityStarted(this); String customContent= clickedResult.getCustomContent(); } 标签 预置标签 目前信鸽提供三类预置标签： 地理位置（省一级） 应用版本号 流失用户（3天or7天） 预置标签会在SDK内部自动上报。 设置标签 开发者可以针对不同的用户设置标签，然后在前台根据标签名群发通知。 一个应用最多有10000个tag， 每个token在一个应用下最多100个tag， tag中不准包含空格。 函数原型 public static void setTag(Context context, String tagName) 参数 context：Context对象 tagName：待设置的标签名称，不能为null或空。 处理结果 可通过重载XGPushBaseReceiver的onSetTagResult方法获取。 示例 XGPushManager.setTag(this, \"male\"); 删除标签 开发者删除用户标签数据。 函数原型 public static void deleteTag(Context context, String tagName) 参数 context：Context对象 tagName：待设置的标签名称，不能为null或空 处理结果 可通过重载XGPushBaseReceiver的onDeleteTagResult方法获取。 示例 XGPushManager.deleteTag (this, \"male\"); 配置接口 所有的配置相关接口在XGPushConfig类中，为了使配置及时生效，开发者需要保证配置接口在启动或注册信鸽之前被调用。 debug模式 （重要：为保证数据的安全性，请在发布时确保已关闭debug模式！！） （1）函数原型 public static void enableDebug(Context context, boolean debugMode) （2）参数 context:APP上下文对象 debugMode：默认为false。如果要开启debug日志，设为true 获取token token（又称MID：Mobile ID）是一个设备的身份识别ID，由服务器根据设备属性随机产生并下发到本地，同一台设备下所有使用信鸽或MTA（腾讯移动分析）的APP获取的token都是相同的。 使用token的一个好处是可以消除山寨机设备ID重复带来的统计影响，提高精准度。 如果您恰好正在使用最新版本的MTA，通过MTA的StatConfig.getMid()接口获取到的mid跟本接口是一样的。 注意：第一次注册会产生token，之后一直存在手机里，不管以后注销注册操作，该token一直存在。在3.0及其以上版本，token 在卸载重装等情况下 可能会改变。 （1）函数原型 public static String getToken(Context context) （2）参数 context：APP上下文对象 （3）返回值 成功时返回正常的token；失败时返回null或”0” 设置AccessID 如果已在AndroidManifest.xml配置过，不需要再次调用；如果2者都存在，则以本接口为准。 （1）函数原型 public static boolean setAccessId(Context context, long accessId) （2）参数 Context对象 accessId：前台注册得到的accessId （3）返回值 true：成功 false：失败 注意：通过本接口设置的accessId会同时存储在文件中 设置AccessKey 如果已在AndroidManifest.xml配置过，不需要再次调用；如果2者都存在，则以本接口为准。 （1）函数原型 public static boolean setAccessId(Context context, String accessKey) （2）参数 Context对象 accessId：前台注册得到的accesskey （3）返回值 true：成功 false：失败 注意：通过本接口设置的accessId会同时存储在文件中 "},"android_access/upgrade_guide.html":{"url":"android_access/upgrade_guide.html","title":"Android SDK 3.X升级指南","keywords":"","body":"信鸽Android 3.版本升级指南 【必须】提取SDK文档中的最新jar包替换当前信鸽SDK版本。 【必须】根据所需平台，提取libtpnsSecurity.so和libxguardian.so替换老版本 【必须】设置XGPushActivity和用户自定义的MessageReceiver的android:exported建议设 置为\"false\" 4.【必须】检查是否配置com.tencent.android.tpush.service.XGPushServiceV3和com.tencent.android.tpush.rpc.XGRemoteService，若无配置则功能不可使用 5.【必须】检查是否配置com.tencent.android.tpush.XGPushProvider、com.tencent.android.tpush.SettingsContentProvider和com.tencent.mid.api.MidProvider，若无配置则功能不可使用 【可选】整理权限 "},"android_access/jcenter.html":{"url":"android_access/jcenter.html","title":"Android SDK 集成指南","keywords":"","body":"Android SDK 集成指南 AndroidStudio自动集成 一导入依赖 AndroidStudio上可以使用jcenter远程仓库自动接入，不需要在项目中导入jar包和so文件； 在AndroidManifest.xml中不需要配置信鸽相关的内容，jcenter 会自动导入。 导入依赖过后修改应用配置，书写注册代码就能够实现信鸽快速接入。 对应的依赖版本号均是，官网上最新的版本。 用户自定义的recevier.依然需要在Androidmanifest.xml配置相关节点。 在app build.gradle文件下配置 以下内容 android { ...... defaultConfig { //信鸽官网上注册的包名.注意application ID 和当前的应用包名以及 信鸽官网上注册应用的包名必须一致。 applicationId \"你的包名\" ...... ndk { //根据需要 自行选择添加的对应cpu类型的.so库。 abiFilters 'armeabi', 'armeabi-v7a', 'arm64-v8a' // 还可以添加 'x86', 'x86_64', 'mips', 'mips64' } manifestPlaceholders = [ XG_ACCESS_ID:\"注册应用的accessid\", XG_ACCESS_KEY : \"注册应用的accesskey\", ] ...... } ...... } dependencies { ...... //完整的信鸽依赖三个都必须有，如果发生依赖冲突请根据对应的依赖版本号选择高版本的依赖。（使用jcenter自动接入请确认libs 中没有信鸽的相关jar包） //信鸽3.2.3 release版本 //完整的信鸽依赖三个都必须有，如果发生依赖冲突请根据对应的依赖版本号选择高版本的依赖。（使用jcenter自动接入请 确认libs 中没有信鸽的相关jar包） //信鸽3.2.4 beta版本 //compile 'com.tencent.xinge:xinge:3.2.4-beta' //信鸽jar compile 'com.tencent.xinge:xinge:3.2.3-release' //wup包 compile 'com.tencent.wup:wup:1.0.0.E-release' //mid包 compile 'com.tencent.mid:mid:4.0.6-release' } ***注意*** 如果在添加以上 abiFilter 配置之后android Studio出现以下提示： NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. 则在 Project 根目录的gradle.properties文件中添加： android.useDeprecatedNdk=true 注 如需监听消息请参考XGBaseReceiver接口或者是demo的MessageReceiver类。自行继承XGBaseReceiver并且在配置文件中配置如下内容： 手动集成 注册并下载SDK 前往信鸽管理台xg.qq.com，使用QQ号码登陆，进入应用注册页，填写“应用名称”和“应用包名”（必须要跟APP一致），选择“操作系统”和“分类”，最后点击“创建应用”。 应用创建成功后，点击“应用配置”即可看到APP专属的AccessId和AccessKey等信息。 注册完成后，请下载最新版本的Android SDK到本地，并解压。 工程配置 将SDK导入到工程的步骤为： （1）创建或打开Android工程（关于如何创建Android工程，请参照开发环境的章节）。 （2）将信鸽 SDK目录下的libs目录所有文件拷贝到工程的libs（或lib）目录下。 （3）选中libs（或lib）目录下的信鸽jar包，右键菜单中选择Build Path， 选择Add to Build Path将SDK添加到工程的引用目录中。 （4）.so文件是信鸽必须的组件，支持armeabi、armeabi-v7a、misp和x86平台，请根据自己当前.so支持的平台添加 a）如果你的项目中没有使用其它.so，建议复制四个平台目录到自己工程中； b）如果已有.so文件，只需要复制信鸽对应目录下的文件； c）若是MSDK接入的游戏，通常只需要armeabi目录下的.so； d）若当前工程已经有armeabi，那么只需要添加信鸽的armeabi下的.so，其它目录无需添加。其它情况类似，只添 加当前 平台存在的平台即可。 e）若在Androidstudio中导入so文件出错（错误10004.SOERROR），在main文件目录下 添加jniLibs命名的文件 夹将所有的架构文件复制进去也就是SDK文档中的Other-Platform-SO下的所有文件夹。如图： （5）打开Androidmanifest.xml，添加以下配置（建议参考下载包的Demo修改），其中YOUR_ACCESS_ID和YOUR_ACCESS_KEY替换为APP对应的accessId和accessKey,请确保按照要求配置，否则可能导致服务不能正常使用。 注册以及部分日志输出。 1.根据手动接入或者自动接入，配置好信鸽过后，获取信鸽注册日志（接入过程中建议调用有回调的注册接口，开启信鸽的debug日志输出。AndroidStudio 建议采用jcenter自动接入，无需在配置文件中配置信鸽各个节点，全部由依赖导入）。 开启debug日志数据 XGPushConfig.enableDebug(this,true); token注册 XGPushManager.registerPush(this, new XGIOperateCallback() { @Override public void onSuccess(Object data, int flag) { //token在设备卸载重装的时候有可能会变 Log.d(\"TPush\", \"注册成功，设备token为：\" + data); } @Override public void onFail(Object data, int errCode, String msg) { Log.d(\"TPush\", \"注册失败，错误码：\" + errCode + \",错误信息：\" + msg); } }) 过滤\"TPush\"注册成功的日志如下： 10-09 20:08:46.922 24290-24303/com.qq.xgdemo I/XINGE: [TPush] get RegisterEntity:RegisterEntity [accessId=2100250470, accessKey=null, token=5874b7465d9eead746bd9374559e010b0d1c0bc4, packageName=com.qq.xgdemo, state=0, timestamp=1507550766, xgSDKVersion=3.11, appVersion=1.0] 10-09 20:08:47.232 24290-24360/com.qq.xgdemo D/TPush: 注册成功，设备token为：5874b7465d9eead746bd9374559e010b0d1c0bc4 设置账号 //注意在3.2.2 版本信鸽对账号绑定和解绑接口进行了升级具体详情请参考API文档。 XGPushManager.bindAccount(getApplicationContext(), \"XINGE\"); 过滤“TPush”账号注册成功的日志如下： //如推送返回48账号无效，请确认账号接口调用成功 10-11 15:55:57.810 29299-29299/com.qq.xgdemo D/TPushReceiver: TPushRegisterMessage [accessId=2100250470, deviceId=853861b6bba92fb1b63a8296a54f439e, account=XINGE, ticket=0, ticketType=0, token=3f13f775079df2d54e1f82475a28bccd3bfef8c1]注册成功 设置标签 XGPushManager.setTag(this,\"XINGE\"); 设置标签成功的日志： 10-09 20:11:42.558 27348-27348/com.qq.xgdemo I/XINGE: [XGPushManager] Action -> setTag with tag = XINGE 收到消息日志 10-16 19:50:01.065 5969-6098/com.qq.xgdemo D/XINGE: [i] Action -> handleRemotePushMessage 10-16 19:50:01.065 5969-6098/com.qq.xgdemo I/XINGE: [i] >> msg from service, @msgId=1 @accId=2100250470 @timeUs=1508154601660412 @recTime=1508154601076 @msg.date= @msg.busiMsgId=0 @msg.timestamp=1508154601 @msg.type=1 @msg.multiPkg=0 @msg.serverTime=1508154601000 @msg.ttl=259200 @expire_time=1508154860200076 @currentTimeMillis=1508154601076 10-16 19:50:01.095 5969-6098/com.qq.xgdemo D/XINGE: [m] Action -> handlerPushMessage 10-16 19:50:01.105 5969-6098/com.qq.xgdemo I/XINGE: [m] Receiver msg from server :PushMessageManager [msgId=1, accessId=2100250470, busiMsgId=0, content={\"n_id\":0,\"title\":\"XGDemo\",\"style_id\":1,\"icon_type\":0,\"builder_id\":1,\"vibrate\":0,\"ring_raw\":\"\",\"content\":\"token 推送\",\"lights\":1,\"clearable\":1,\"action\":{\"aty_attr\":{\"pf\":0,\"if\":0},\"action_type\":1,\"activity\":\"\"},\"small_icon\":\"\",\"ring\":1,\"icon_res\":\"\",\"custom_content\":{}}, timestamps=1508154601, type=1, intent=Intent { act=com.tencent.android.tpush.action.INTERNAL_PUSH_MESSAGE cat=[android.intent.category.BROWSABLE] pkg=com.qq.xgdemo (has extras) }, messageHolder=BaseMessageHolder [msgJson={\"n_id\":0,\"title\":\"XGDemo\",\"style_id\":1,\"icon_type\":0,\"builder_id\":1,\"vibrate\":0,\"ring_raw\":\"\",\"content\":\"token 推送\",\"lights\":1,\"clearable\":1,\"action\":{\"aty_attr\":{\"pf\":0,\"if\":0},\"action_type\":1,\"activity\":\"\"},\"small_icon\":\"\",\"ring\":1,\"icon_res\":\"\",\"custom_content\":{}}, msgJsonStr={\"n_id\":0,\"title\":\"XGDemo\",\"style_id\":1,\"icon_type\":0,\"builder_id\":1,\"vibrate\":0,\"ring_raw\":\"\",\"content\":\"token 推送\",\"lights\":1,\"clearable\":1,\"action\":{\"aty_attr\":{\"pf\":0,\"if\":0},\"action_type\":1,\"activity\":\"\"},\"small_icon\":\"\",\"ring\":1,\"icon_res\":\"\",\"custom_content\":{}}, title=XGDemo, content=token 推送, customContent=null, acceptTime=null]] 10-16 19:50:01.105 5969-6098/com.qq.xgdemo V/XINGE: [XGPushManager] Action -> msgAck(com.qq.xgdemo,1) 10-16 19:50:01.115 5969-6098/com.qq.xgdemo I/XINGE: [TPush] title encry obj:{\"cipher\":\"YZXM+CuPhqaBn4eK0SE9ApWieHznugNT2uKo0OaXtlDDHLJiY7NlvSL2ZnlSb8E7yd7E7i9JU3g0PlFyYNLjokNp1buJuPoMYEHaJ0s6vmUMY+cq0Sv782XHxNzekV4a9mRcJ5xsOccIjH1VoskUmikfZJo3XLhZveWNYGPaoto=\"} 10-16 19:50:01.125 5969-6098/com.qq.xgdemo E/XINGE: [MessageInfoManager] delOldShowedCacheMessage Error! toDelTime: 1507981801138 10-16 19:50:01.145 5969-6098/com.qq.xgdemo I/XINGE: [MessageHelper] Action -> showNotification {\"n_id\":0,\"title\":\"XGDemo\",\"style_id\":1,\"icon_type\":0,\"builder_id\":1,\"vibrate\":0,\"ring_raw\":\"\",\"content\":\"token 推送\",\"lights\":1,\"clearable\":1,\"action\":{\"aty_attr\":{\"pf\":0,\"if\":0},\"action_type\":1,\"activity\":\"\"},\"small_icon\":\"\",\"ring\":1,\"icon_res\":\"\",\"custom_content\":{}} 推送问题 推送时效性问题 全量推送接口，批量推送接口（批量账号，批量token，tag），会有一个30秒左右的任务调度时间。单推接口基本上秒达。（单推账号，单推token）秒达。注：在中午12点。晚6点到8点为推送高峰期，部分消息可能会延时到达。 本地通知延时 需要保证应用在前台，信鸽service存活，正常运行。本地通知才能展示，关闭应用无法展示本地通知，本地通知是根据网络心跳来判断弹出通知 大约5分钟一次心跳，不能保证准时弹出推送前后可能会有一定的时间差 收不到推送的问题 用获取到的token，在信鸽web推送。如无法收到推送请根据以下情况进行排查（请确保SDK版本是最新的版本，如果是旧版本出现问题，在新版本可能已经修复，如遇到web端推送报错，请刷新页面重试）。 注册成功无法收到推送： a.请查看当前的应用包名是否和注册信鸽应用时填写的应用包名是否一致。如果不一致，推送的时候 建议开启多包名推送。 b.查看设备是否开启通知栏权限，oppo,vivo.等手机，需要手动开启通知栏权限。 c.信鸽推送分为通知栏消息，和应用内消息（透传消息），通知栏消息可以展示到通知栏，应用内消息不能展示到通知栏。 d.确认手机当前模式是正常模式，部分手机在低电量，勿扰模式，省电模式下，会对后台信鸽进程进行一系列网络和活动的限制。 注册不成功无法收到推送： A.注册返回错误: 如10004，20.等请参考信鸽错误码表。 错误10004 原因：so文件导入不全，so是用来适配各种设备的不同型号的CPU，如出现10004的错误，应该查看 当前导入的so库文件是否支持当前设备的CPU。如果不支持需要添加对应的so文件（完整的SO库 在SDK文件夹下Other-Platform-SO目录内）。 eclipse开发工具解决办法： 将需要的对应设备CPU的SO文件复制到lib目前中。 Androidstudio的开发工具的解决办法： Androidstudio可在main文件目录下 添加jniLibs命名的文件夹将SDK文档中的Other-Platform-SO下的7个so库文件夹添加至该目录 ，或者采用自动接入，无须手动导入so文件。 B.如注册无回调: 确认当前网络情况是否良好（建议使用4G网络测试，wifi由于使用人数过多可能造成 网络带宽不足），是否添加wup包，以及努比亚手机(部分机型不支持第三方推送)在 2015年下半年和2016年出的机器都无法注册，具体机型包括nubia Z11系列，nubiaZ11S系列，nubiaZ9S系列。可以的机器都是之前的机器，包括Z7系列，my布拉格系列（在信鸽2.47和信鸽3.X上都有这个现象）。 关闭应用无法收到推送 目前第三方推送都无法保证关闭应用过后还可以收到推送消息，这个是手机定制ROM对信鸽service的限制问题，信鸽的一切活动都需要建立在信鸽的service能够正常联网运行。 QQ，微信是系统级别的应用白名单，相关的service不会应用关闭应用而退出所以用户感知推出应用过后还可以收到消息其实相关的service 还是能够在后台存活的。 Android端在应用退出，信鸽service和信鸽的服务器断开连接后，这个时候给这个设备下发的消息，会变成离线消息，离线消息最多保存72消息，每个设备最多保存两条，如果有多条离线消息。在关闭应用期间推送的消息，如开启应用无法收到，请检查是否调用了反注册接口：XGPushManager.unregisterPush(this);。 账号推送收不到 每个账号最多可以绑定15个设备，超过15个设备，会自动顶掉最先绑定的一个账号。每个设备注册的有效账号为最后一次绑定的账号，如果多个设备同时绑定多个账号，则全部能收到推送。 tag推送收不到 请确认tag标签是否绑定成功，一个应用最多有10000个 标签（tag）， 每个token在一个应用下最多100个 标签（tag）， 标签（tag）中不准包含空格。 信鸽推送是否支持海外 只要能ping通信鸽服务器域名 openapi.xg.qq.com 就能够收到推送消息，信鸽海外服务器部署在香港，由于在海外地区网络延时较高，信鸽在海外的推送效果会略低于在国内的推送效果。 测试方法： 在想测试的网络环境，打开命令行，输入 ping openapi.xg.qq.com 再回车 终端输出如下日志 表示能够成功连上信鸽服务器： admin$ ping openapi.xg.qq.com PING openapi.xg.qq.com (******* ip地址): 56 data bytes 64 bytes from 14.215.138.42: icmp_seq=0 ttl=54 time=4.364 ms 64 bytes from 14.215.138.42: icmp_seq=1 ttl=54 time=5.352 ms 64 bytes from 14.215.138.42: icmp_seq=2 ttl=54 time=4.514 ms 64 bytes from 14.215.138.42: icmp_seq=3 ttl=54 time=4.924 ms 64 bytes from 14.215.138.42: icmp_seq=4 ttl=54 time=4.447 ms 64 bytes from 14.215.138.42: icmp_seq=5 ttl=54 time=4.843 ms 64 bytes from 14.215.138.42: icmp_seq=6 ttl=54 time=5.946 ms 推送数据问题 推送暂停 a.相同的内容的全量推送每小时只能推送一次，超过一次推送会被暂停。 b.每小时最多推送30条全量推送，超过三十次会被暂停。 效果统计 【次日】：推送完第二天才能看到推送数据； 【实时】：推送完马上可以看到推送数据。目前每周仅支持14次的实时数据统计。 实发 在消息离线保存时间内，有成功连接到信鸽服务器，并且有正常下发的量。（如：消息离线保存时间为3天，实发数据会在第四天稳定，数据会随着设备不断开启连接到信鸽服务器的数量而增加）。 历史明细 历史明细 只展示全量推送，tag推送，和官网的号码包推送。\u0010（其他推送接口不展示推送详情） 数据概览 展示的是当天的数据，某天的数据是在那一天中各种推送行为的推送总量。（分为单推，广播也就是批量和全量推送，通知栏消息和应用内消息四类） 消息点击事件，以及跳转页面方法。 由于目前sdk点击 消息默认会有点击事件，默认的点击事件是打开主界面。所以在终端点击消息回调onNotifactionClickedResult方法内，设置跳转操作，自定义的跳转和默认的点击事件造成冲突。反应情况是会跳转到指定界面过后再回到主界面。所以不能再onNotifactionClickedResult内设置跳转。 解决办法如下(推荐使用第一种方式)： 一.在下发消息的时候设置点击消息要跳转的页面。 a.可以直接在web端高级功能内设置deeplink包名+类名） ; b.后台设置Messege 类中的 Action字段的 的SetActivity方法（包名+类名），通过XGPushClickedResult 可以获取到消息的相关内容。标题 ，内容，和附加参数。 后台设置跳转页面的方法如下（以javaSDK为例）： ...... XingeApp android= new XingeApp(access ID, secret key); Message message_android = new Message(); message_android.setExpireTime(86400); message_android.setTitle(\"信鸽推送\"); message_android.setType(1); message_android.setContent(\"android test2\"); ClickAction action = new ClickAction(); action.setActivity(\"com.qq.xgdemo.activity.SettingActivity\"); message_android.setAction(action); JSONObject ret1= android.pushSingleDevice(\"token\",message_android); ...... 终端获取Message 个参数的方法如下: //this必须为点击消息要跳转到页面的上下文。 XGPushClickedResult clickedResult = XGPushManager.onActivityStarted(this); //获取消息附近参数 String ster= clickedResult.getCustomContent(); //获取消息标题 String set = clickedResult.getTitle(); //获取消息内容 String s= clickedResult.getContent(); 二.发应用内消息到终端，用户自定义通知栏，采用本地通知弹出通知，设置要跳转的页面。 三.使用Intent来跳转指定页面（Android 3.2.3版本使用此方式） 1.需要在客户端app的manifest上配置要跳转的页面，如要跳转AboutActivity指定页面： 2.若使用服务端SDK设置intent进行跳转，可设置intent为（以Java SDK为例）： action.setIntent(\"xgscheme://com.xg.push/notify_detail\"); 包冲突 (1)jar包冲突： 如果提示jar包冲突，请删除冲突的包，保留一份即可，建议保留版本高的。 常见的冲突有： a）MSDK与信鸽冲突：删除wup.jar b）MTA与信鸽冲突：删除低版本的mid.jar 代码混淆 如果你的项目中使用proguard等工具做了代码混淆，请保留以下选项，否则将导致信鸽服务不可用。 -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep class com.tencent.android.tpush.** {* ;} -keep class com.tencent.mid.** {* ;} -keep class com.qq.taf.jce.** {*;} 多行显示 Android多行显示特性，在2.38及以上版本已经实现并默认开启，但此功能部分机型生效。 多包名推送 目前市场上部分app针对不同渠道有不同的包名，同一款app可能会有上百个包名，这时就可以利用access id向该app的所有包名进行推送。在多包名推送模式下，设备上所有使用这个access id注册推送的app都会收到这条消息。具体实现方法:在进行推送前， a:在服务端推送时可将推送参数 multi_pkg 设置为1； b:在web端推送时可在高级功能中开启多包名推送。 "},"android_access/huawei_push.html":{"url":"android_access/huawei_push.html","title":"华为推送通道集成指南","keywords":"","body":"华为推送通道集成指南 华为推送通道是由华为官方提供的系统级推送通道。在华为手机上，推送消息能够通过华为的系统通道抵达终端，并且无需打开应用就能够收到推送。使用此功能必须先集成信鸽3.2.1-beta以上版本。 注意事项： 华为推送只有在签名发布包环境下才可以收到推送消息 华为手机中的移动推送服务，必须升级到2.5.3以上版本，华为通道会注册失败（依旧走信鸽通道）。 获取华为推送密钥 1.打开华为开放平台 2.注册/登录开发者账号。（如果您是新注册账号，需进行实名认证） 3.在华为推送平台中新建应用。注意「应用包名」需跟您在信鸽填写的包名保持一致 4.获取应用相关的信息，并且将这些信息复制，填入信鸽管理台的“应用配置”-“厂商&海外通道”栏目中，这些信息是AppID，AppSecret 配置SHA256证书指纹 [配置示例] 获取SHA256证书指纹方法请参照华为推送接入文档 集成指南 AndroidStudio集成方法 在app模块下的build.gradle文件内先配置好信鸽所需要的配置之后再增加以下的华为节点： 1.配置华为APPID。 manifestPlaceholders = [ HW_APPID: \"华为的APPID\" ] 2.导入华为推送相关依赖。 compile 'com.tencent.xinge:xghw:2.5.2.300-release' //华为3.2.4 beta版本 //compile 'com.tencent.xinge:xghw:3.2.4-beta' 3.配置华为消息receiver. 注：如果使用xghw:3.2.4-beta版本则不需要此步骤，只需要前两步即可 Eclipes集成方法 1.导入华为推送相关jar包 将HMSSdkBase*.jar，HMSSdkPush*.jar放在libs文件夹里。 2.在Androidmanifest.xml 文件中新增如下配置： 3.2.配置华为消息receiver. 华为消息receiver 1.自定义类，继承com.huawei.hms.support.api.push.PushReceiver，并且在Androidmanifest.xml中配置相关的节点。 示例代码： public class MyReceiver extends PushReceiver { @Override public void onEvent(Context context, Event arg1, Bundle arg2) { super.onEvent(context, arg1, arg2); showToast(\"onEvent\" + arg1 + \" Bundle \" + arg2 , context); } @Override public boolean onPushMsg(Context context, byte[] arg1, Bundle arg2) { showToast(\"onPushMsg\" + new String(arg1) + \" Bundle \" + arg2 , context); return super.onPushMsg(context, arg1, arg2); } @Override public void onPushMsg(Context context, byte[] arg1, String arg2) { showToast(\"onPushMsg\" + new String(arg1) + \" arg2 \" + arg2 , context); super.onPushMsg(context, arg1, arg2); } @Override public void onPushState(Context context, boolean arg1) { showToast(\"onPushState\" + arg1, context); super.onPushState(context, arg1); } @Override public void onToken(Context context, String arg1, Bundle arg2) { super.onToken(context, arg1, arg2); showToast(\" onToken\" + arg1 + \"bundke \" + arg2, context); } @Override public void onToken(Context context, String arg1) { super.onToken(context, arg1); showToast(\" onToken\" + arg1 , context); } public void showToast(final String toast, final Context context) { new Thread(new Runnable() { @Override public void run() { Looper.prepare(); Toast.makeText(context, toast, Toast.LENGTH_SHORT).show(); Looper.loop(); } }).start(); } private void writeToFile(String conrent) { String SDPATH = Environment.getExternalStorageDirectory() + \"/huawei.txt\"; try { FileWriter fileWriter = new FileWriter(SDPATH, true); fileWriter.write(conrent+\"\\r\\n\"); fileWriter.flush(); fileWriter.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 2.在AndroidManifest.xml 增加自定义Receiver 配置如下： 启动华为推送以及注册日志 在调用信鸽（XGPushManager.registerPush）之前开启第三方推送接口： //打开第三方推送 XGPushConfig.enableOtherPush(getApplicationContext(), true); 注册成功的日志如下： 01-15 16:40:41.116 17916-17934/? I/XINGE: [XGOtherPush] other push token is : 0865551032618726300001294600CN01 other push type: huawei 01-15 16:40:41.122 15730-15846/? I/XINGE: [a] binder other push token with accid = 2100274337 token = 17c32948df0346d5837d4748192e9d2f14c81e08 otherPushType = huawei otherPushToken = 0865551032618726300001294600CN01 如果出现： otherPushType = huawei otherPushToken = null,这个日志 请在注册代码之前调用： XGPushConfig.setHuaweiDebug(true); 请手动确认给应用存储权限，然后查看SD卡目录下的huawei.txt文件内输出的注册华为失败的错误原因。然后根据华为开发文档对应的错误码原因，以及解决办法。 代码混淆 -ignorewarning -keepattributes *Annotation* -keepattributes Exceptions -keepattributes InnerClasses -keepattributes Signature -keepattributes SourceFile,LineNumberTable -keep class com.hianalytics.android.**{*;} -keep class com.huawei.updatesdk.**{*;} -keep class com.huawei.hms.**{*;} 厂商通道测试方法 在您的App中集成信鸽V3.2.1以上版本的SDK，并且按照「厂商通道集成指南」集成所需的厂商SDK 确认已在信鸽管理台中「应用配置-厂商&海外通道」中填写相关的应用信息。通常，相关配置将在1个小时后生效，请您耐心等待，在生效后再进行下一个步骤 将集成好的App（测试版本）安装在测试机上，并且运行App 保持App在前台运行，尝试对设备进行单推/全推 如果应用收到消息，将App退到后台，并且杀掉所有App进程 再次进行单推/全推，如果能够收到推送，则表明厂商通道集成成功 "},"android_access/meizu_push.html":{"url":"android_access/meizu_push.html","title":"魅族推送通道集成指南","keywords":"","body":"魅族推送通道集成指南 魅族推送通道是由魅族官方提供的系统级推送通道。在魅族手机上，推送消息能够通过魅族的系统通道抵达终端，并且无需打开应用就能够收到推送。使用此功能必须先集成信鸽3.2.1-beta以上版本。 [注意事项] 魅族推送通道通知标题不超过32字符，通知内容不超过100字符 魅族推送通道不支持透传消息 获取魅族魅族推送密钥 1.打开魅族推送官网 2.注册/登录开发者账号。（如果您是新注册账号，进行实名认证大约需要2天左右时间，具体请咨询魅族侧） 3.在魅族推送平台（http://push.meizu.com） 中新建应用。注意「应用包名」需跟您在信鸽填写的包名保持一致 4.获取应用相关的信息，并且将这些信息复制，填入信鸽管理台“应用配置”-“厂商&海外通道”栏目，这些信息是AppID，AppKey，AppSecret 注：更多详情请参照魅族开发文档 5.在信鸽管理台-应用配置-厂商&海外通道处-魅族推送通道处，将相关推送密钥填入。 集成方式 AndroidStudio集成方式 1.在app模块下的build.gradle中添加魅族通道所需要依赖（使用Androidstudio默认仓库jcenter）: compile 'com.tencent.xinge:xgmz:3.2.2-release' // 魅族3.2.4-beta版 // compile 'com.tencent.xinge:xgmz:3.2.4-beta' 2.配置魅族消息receiver。 注：如果使用xgmz:3.2.4-beta版本则不需要此步骤，只需要添加依赖即可 Eclipse集成方式 1.将魅族通道所需要的jar包（pushsdk-3.3.170110.jar）导入libs目录下： 2.在Androidmanifest下配置一下配置： 魅族消息receiver 如需要自定义魅族消息的广播需要新建类继承（MzPushMessageReceiver）。然后在Androidmanifest.xml中配置一下节点： 启动代码已经注册日志输出 在启动信鸽(XGPushManager.registerPush)之前配置如下代码： //设置魅族APPID和APPKEY XGPushConfig.enableOtherPush(context, true); XGPushConfig.setMzPushAppId(this, APP_ID); XGPushConfig.setMzPushAppKey(this, APP_KEY); 注册成功的日志如下： //成功的获取到信鸽的token和魅族的token，并且绑定成功说明注册成功 INFO16:24:27.94313075XINGE[a] >> bind OtherPushToken success ack with [accId = 2100273138 , rsp = 0] token = 08d7ea8e4b93952cbfdd2cb68461342c314d281a otherPushType = meizu otherPushToken = ULY6c5968627059714a475c63517f675b7f655e62627e 代码混淆 -dontwarn com.meizu.cloud.pushsdk.** -keep class com.meizu.cloud.pushsdk.**{*;} 厂商通道测试方法(通用) 在您的App中集成信鸽V3.2.1以上版本的SDK，并且按照「厂商通道集成指南」集成所需的厂商SDK 确认已在信鸽管理台中「应用配置-厂商&海外通道」中填写相关的应用信息。通常相关配置将在1个小时后生效，请您耐心等待，在生效后再进行下一个步骤 将集成好的App（测试版本）安装在测试机上，并且运行App 保持App在前台运行，尝试对设备进行单推/全推 如果应用收到消息，将App退到后台，并且杀掉所有App进程 再次进行单推/全推，如果能够收到推送，则表明厂商通道集成成功 "},"android_access/mi_push.html":{"url":"android_access/mi_push.html","title":"小米推送通道集成指南","keywords":"","body":"小米推送通道集成指南 小米推送通道是由小米官方提供的系统级推送通道。在小米手机上，推送消息能够通过小米的系统通道抵达终端，并且无需打开应用就能够收到推送。使用此功能必须先集成信鸽3.2.0以上版本。 获取小米推送秘钥 (a)根据小米开放平台指引开通小米开发者账号,然后注册应用并获取小米推送的秘钥。 认证小米开发者： 获取小米推送密钥： 配置小米推送相关内容 AS开发建议使用jcenter依赖接入 1.配置包名。 manifestPlaceholders = [ PACKAGE_NAME:\"应用包名\" ] 2.引入小米推送的jar包 //需要在信鸽的集成基础上新增小米push的jar包 compile 'com.tencent.xinge:mipush:3.2.2-release' //小米3.2.4-beta版 //compile 'com.tencent.xinge:mipush:3.2.4-beta' 3.新建一个类继承小米PushMessageReceiver，然后再Androidmanif.xml 中配置。根据小米的要求次节点必须配置 注：如果使用mipush:3.2.4-beta版本则不需要此步骤，只需要前两步即可 Eclipse开发接入 1.引入小米推送的jar包，可以在小米推送web官网下载小米的jar包。 2.在配置好信鸽的基础上 ，新增小米推送的配置: 3.新建一个类继承小米PushMessageReceiver，然后再Androidmanif.xml 中配置。根据小米的要求此节点必须配置： 开启小米推送 设置小米APPID和APPKEY。 XGPushConfig.setMiPushAppId(getApplicationContext(), \"APPID\"); XGPushConfig.setMiPushAppKey(getApplicationContext(), \"APPKEY\"); //打开第三方推送 XGPushConfig.enableOtherPush(getApplicationContext(), true); //注册成功的日志如下 12-02 16:17:32.299 12584-12584/com.qq.xgdemo I/XINGE: [XGPushManager] Action -> Register to xinge server 12-02 16:17:32.996 12584-12584/com.qq.xgdemo I/XINGE: [XGPushManager] Register call back to com.qq.xgdemo 12-02 16:17:32.997 12584-12626/com.qq.xgdemo I/XINGE: [XGPushManager] XG register push success with token : 1d31bb3ea6185baebdf05dfc2e586dfe5dc41fb5 12-02 16:17:33.001 12584-12626/com.qq.xgdemo I/XINGE: [XGOtherPush] other push token is : YZQfRxmxdfNlbSKpNWCa3tM4Esnq6op4qeOsQO2qT88= other push type: xiaomi 代码混淆 -keepclasseswithmembernames class com.xiaomi.**{*;} -keep public class * extends com.xiaomi.mipush.sdk.PushMessageReceiver 厂商通道测试方法(通用) 在您的App中集成信鸽V3.2.1以上版本的SDK，并且按照「厂商通道集成指南」集成所需的厂商SDK 确认已在信鸽管理台中「应用配置-厂商&海外通道」中填写相关的应用信息。通常相关配置将在1个小时后生效，请您耐心等待，在生效后再进行下一个步骤 将集成好的App（测试版本）安装在测试机上，并且运行App 保持App在前台运行，尝试对设备进行单推/全推 如果应用收到消息，将App退到后台，并且杀掉所有App进程 再次进行单推/全推，如果能够收到推送，则表明厂商通道集成成功 "},"android_access/testdemo.html":{"url":"android_access/testdemo.html","title":"Android测试Demo用法介绍","keywords":"","body":"信鸽测试Demo的用法介绍 下载Demo 信鸽的demo工程在SDK文件内，需要先行下载SDK。 注册测试应用 注册测试应用的名称不限，但是包名必须为com.qq.xgdemo。（如果包名不一致推送的时候需要勾选多包名推送）。并获取注册完整过后应用对应的ACCESSID和ACCESSKEY。 配置工程 AndroidStudio工程 需要将获取到的测试应用的ACCESSID和ACCESSKEY配置到demo工程app模块下的build.gradle文件下的ManifestPlaceholders节点。如图所示： Eclipse工程 需要将获取到的测试应用的ACCESSID和ACCESSKEY配置到demo工程中的AndroidManifest.xml文件下的节点下! 运行代码 出现如下日志说明信鸽注册成功。（日志tag:\"TPush\"）: 10-09 20:08:46.922 24290-24303/com.qq.xgdemo I/XINGE: [TPush] get RegisterEntity:RegisterEntity [accessId=2100250470, accessKey=null, token=5874b7465d9eead746bd9374559e010b0d1c0bc4, packageName=com.qq.xgdemo, state=0, timestamp=1507550766, xgSDKVersion=3.11, appVersion=1.0] 10-09 20:08:47.232 24290-24360/com.qq.xgdemo D/TPush: 注册成功，设备token为：5874b7465d9eead746bd9374559e010b0d1c0bc4 推送测试 获取日志输出的设备token。通过信鸽web端的应用管理中创建推送。如图所示 "},"ios_access.html":{"url":"ios_access.html","title":"iOS接入","keywords":"","body":"iOS接入 在接入iOS SDK之前，请开发者先完成iOS证书设置，完成证书设置之后，可进行SDK完整集成。 iOS证书设置指南 iOS SDK V2.5.0 完整接入 iOS SDK V3.0 完整接入 "},"ios_access/certificate_config.html":{"url":"ios_access/certificate_config.html","title":"iOS 证书设置指南","keywords":"","body":"iOS 证书设置指南 iOS证书命令 证书有效期 openssl x509 -in xxx.pem -noout -dates 连接APNS测试证书是否合法 1、开发环境 openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert xxx.pem -key xxx.pem 2、生产环境 openssl s_client -connect gateway.push.apple.com:2195 -cert xxx.pem -key xxx.pem 指南介绍 本指南用于介绍iOS证书如何设置 配置好证书后请前往iOS SDK 完整接入 设置步骤 首先，登录苹果开发者中心网站。然后点击Certificates,Identifiers & Profiles 然后点击Certificates 选中需要制作Push证书的应用，勾选Push服务 下面以制作开发证书为例演示。点击Create Certificate… 然后打开Keychain Access工具 选择Request a Certificate From a Certificate Authority… 填写邮件地址，其它留空, 继续。会将证书保存到本地 返回网站，选择刚才创建的文件上传 成功后，下载到本地 再次打开Keychain Access。选中Push证书导出，选中一行。导出的格式为p12 生成pem格式的证书 完成上述操作后，打开终端，进入到p12文件所在执行以下命令: openssl pkcs12 -in CertificateName.p12 -out CertificateName.pem -nodes 则生成了CertificateName.pem证书，上传到信鸽则可以进行消息推送。 iOS SDK相关开发请前往iOS SDK 完整接入 "},"ios_access/api_2.5.0.html":{"url":"ios_access/api_2.5.0.html","title":"iOS SDK v2.5.0 完整接入","keywords":"","body":"信鸽 iOS SDK 开发指南 简介 信鸽iOS SDK是一个能够提供Push服务的开发平台，提供给开发者简便、易用的API接口，方便快速接入。 接入方法 (1)获取 AppId 和 AppKey (2)工程配置 获取 AppId 和 AppKey 前往http://xg.qq.com注册并获取AppKey 工程配置 （1）下载信鸽 SDK, 解压缩。注：使用CocoaPods的用户可以通过如下名称管理信鸽： pod 'QQ_XGPush' （2）将 XGSetting.h, XGPush.h 以及 libXG-SDK.a 添加到工程 （3）添加以下库/framework 的引用 CoreTelephony.framework, SystemConfiguration.framework, UserNotifications.framework, libXG-SDK.a 以及 libz.tbd.添加完成以后,库的引用如下 （4）在工程配置和后台模式中打开推送,如下图 （5）参考 Demo, 添加相关代码 API 接口 开启 Debug 打开 Debug 模式以后可以在终端看到详细的信鸽 Debug 信息.方便定位问题 示例 //打开debug开关 XGSetting *setting = [XGSetting getInstance]; [setting enableDebug:YES]; //查看debug开关是否打开 BOOL debugEnabled = [setting isEnableDebug]; 初始化信鸽 在使用信鸽之前,需要先在UIApplicationDelegate中的 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions; 回调中调用信鸽的初始化方法才能正常使用信鸽 (1)接口 /** 初始化信鸽 @param appId 通过前台申请的应用ID @param appKey 通过前台申请的appKey */ +(void)startApp:(uint32_t)appId appKey:(nonnull NSString *)appKey; (2)示例 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [XGPush startApp:1234567890 appKey:@\"ABCDEFGHIJKLMN\"]; } 注册苹果推送服务 使用推送前,需要先向苹果注册推送服务. 请参考 Demo 向苹果注册推送服务. 示例 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // 详细代码参考 Demo 中 registerAPNS 的实现 [self registerAPNS]; } 注: 在 iOS 10 中也可以可以使用 iOS 10 之前的注册方法来注册推送,但是对应的,也要使用 iOS 10 之前的方法来接收推送 注册信鸽 向苹果注册完成推送服务以后,还需要向信鸽注册推送.在UIApplicationDelegate的 - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken; 回调中调用信鸽的 registerDevice 方法即可完成信鸽注册 (1)接口 /** 注册设备 @param deviceToken 通过appdelegate的didRegisterForRemoteNotificationsWithDeviceToken 回调的获取 @param successCallback 成功回调 @param errorCallback 失败回调 @return 获取的 deviceToken 字符串 */ +(nullable NSString *)registerDevice:(nonnull NSData *)deviceToken successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; /** 注册设备并且设置账号 @param deviceToken 通过appDelegate的didRegisterForRemoteNotificationsWithDeviceToken 回调的获取 @param account 需要设置的账号,长度为2个字节以上，不要使用\"test\",\"123456\"这种过于简单的字符串, 若不想设置账号,请传入nil @param successCallback 成功回调 @param errorCallback 失败回调 @return 获取的 deviceToken 字符串 */ +(nullable NSString *)registerDevice:(nonnull NSData *)deviceToken account:(nullable NSString *)account successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; /** 注册设备并且设置账号, 字符串 token 版本 @param deviceToken NSString *类型的 token @param account 需要设置的账号,若不想设置账号,请传入 nil @param successCallback 成功回调 @param errorCallback 失败回调 @return 获取的 deviceToken 字符串 */ +(nullable NSString *)registerDeviceStr:(nonnull NSString *)deviceToken account:(nullable NSString *) account successCallback:(nullable void(^)(void)) successCallback errorCallback:(nullable void(^)(void))errorCallback; (2)示例 - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken { NSString *deviceTokenStr = [XGPush registerDevice:deviceToken account:nil successCallback:^{ NSLog(@\"[XGPush Demo] register push success\"); } errorCallback:^{ NSLog(@\"[XGPush Demo] register push error\"); }]; NSLog(@\"[XGPush Demo] device token is %@\", deviceTokenStr); } 注意：account是需要设置的账号,视业务需求自定义,可以是用户的名称或者ID等,长度为2个字节以上，不要使用\"myAccount\"或者\"test\",\"123456\"这种过于简单的字符串,若不想设置账号，请传入nil 设置/删除标签 开发者可以针对不同的用户设置标签,然后对该标签推送.对标签推送会让该标签下的所有设备都收到推送.一个设备可以设置多个标签. (1)接口 /** 设置 tag @param tag 需要设置的 tag @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)setTag:(nonnull NSString *)tag successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; /** 删除tag @param tag 需要删除的 tag @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)delTag:(nonnull NSString *)tag successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; (2)示例 - (void)setTag:(NSString *)tag { [XGPush setTag:@\"myTag\" successCallback:^{ NSLog(@\"[XGDemo] Set tag success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Set tag error\"); }]; } - (void)delTag:(NSString *)tag { [XGPush delTag:@\"myTag\" successCallback:^{ NSLog(@\"[XGDemo] Del tag success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Del tag error\"); }]; } 设置/删除账号 开发者可以针对不同的用户设置账号,然后对账号推送.对账号推送会让该账号下的所有设备都收到推送. 注1: 一个账号最多绑定15台设备,超过之后会随机解绑一台设备,然后再进行注册. 注2: 老版本不带回调的接口要求设置/删除账号后再调用一次注册设备的方法,但是新版带回调的接口不需要再调用注册设备的方法 (1)接口 /** 设置设备的帐号. 设置账号前需要调用一次registerDevice @param account 需要设置的账号,长度为2个字节以上，不要使用\"test\",\"123456\"这种过于简单的字符串 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)setAccount:(nonnull NSString *)account successCallback:(nullable void(^)(void)) successCallback errorCallback:(nullable void(^)(void)) errorCallback; /** 删除已经设置的账号. 删除账号前需要调用一次registerDevice @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)delAccount:(nullable void(^)(void)) successCallback errorCallback:(nullable void(^)(void)) errorCallback; (2)示例 - (void)setAccount:(NSString *)account { [XGPush setAccount:@\"myAccount\" successCallback:^{ NSLog(@\"[XGDemo] Set account success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Set account error\"); }]; } - (void)delAccount { [XGPush delAccount:^{ NSLog(@\"[XGDemo] Del account success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Del account error\"); }]; } 注销设备 注销设备以后,可以让该设备不再接收推送. （1）接口 /** 注销设备，设备不再进行推送 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)unRegisterDevice:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; （2）示例 [XGPush unRegisterDevice:^{ NSLog(@\"[XGDemo] unregister success\"); } errorCallback:^{ NSLog(@\"[XGDemo] unregister error\"); }]; 注意：重新开启推送功能需要再次调用registerAPNS和registerDevice接口。 推送效果统计 如果需要统计由信鸽推送的点击或者打开. 统计打开 对于统计打开需要开发者在UIApplicationDelegate中的 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions; 调用 handleLaunching 方法 (1)接口 /** 在didFinishLaunchingWithOptions中调用，用于推送反馈.(app没有运行时，点击推送启动时) @param launchOptions didFinishLaunchingWithOptions中的userinfo参数 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)handleLaunching:(nonnull NSDictionary *)launchOptions successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; (2)示例 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [XGPush handleLaunching:launchOptions successCallback:^{ NSLog(@\"[XGDemo] Handle launching success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Handle launching error\"); }]; } 统计点击 iOS 10 以前的系统版本 对于 iOS 10 以前的系统版本,需要在 UIApplicationDelegate 中的 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo; 中调用 handleReceiveNotification 方法 (1)接口 /** 在didReceiveRemoteNotification中调用，用于推送反馈。(app在运行时) @param userInfo 苹果 apns 的推送信息 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)handleReceiveNotification:(nonnull NSDictionary *)userInfo successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; (2)示例 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo { NSLog(@\"[XGPush Demo] receive Notification\"); [XGPush handleReceiveNotification:userInfo successCallback:^{ NSLog(@\"[XGDemo] Handle receive success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Handle receive error\"); }]; } iOS 10 对于 iOS 10, 需要在 UNUserNotificationCenterDelegate 的 - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler; 中调用 handleReceiveNotification 方法 (1)接口 /** 在didReceiveRemoteNotification中调用，用于推送反馈。(app在运行时) @param userInfo 苹果 apns 的推送信息 @param successCallback 成功回调 @param errorCallback 失败回调 */ +(void)handleReceiveNotification:(nonnull NSDictionary *)userInfo successCallback:(nullable void (^)(void)) successCallback errorCallback:(nullable void (^)(void)) errorCallback; (2)示例 - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler { [XGPush handleReceiveNotification:response.notification .request.content.userInfo successCallback:^{ NSLog(@\"[XGDemo] Handle receive success\"); } errorCallback:^{ NSLog(@\"[XGDemo] Handle receive error\"); }]; completionHandler() } 本地推送 本地推送相关功能请参考苹果开发者文档. "},"ios_access/api_3.0.html":{"url":"ios_access/api_3.0.html","title":"iOS SDK v3.0 完整接入","keywords":"","body":"信鸽 iOS SDK 开发指南 简介 信鸽iOS SDK是一个能够提供Push服务的开发平台，提供给开发者简便、易用的API接口，方便快速接入。 接入方法 获取 AppId 和 AppKey 工程配置 获取 AppId 和 AppKey 前往http://xg.qq.com注册并获取AppKey 工程配置 下载信鸽 SDK, 解压缩。 将XGPush.h 以及 libXG-SDK.a 添加到工程 添加以下库/framework 的引用 CoreTelephony.framework, SystemConfiguration.framework, UserNotifications.framework, libXG-SDK.a 以及 libz.tbd, libsqlite3.0.tbd 添加完成以后,库的引用如下: 在工程配置和后台模式中打开推送,如下图 添加编译参数-ObjC 注意：checkTargetOtherLinkFlagForObjc报错，是因为build setting中，Other link flags未添加-ObjC 参考 Demo, 添加相关代码 管理信鸽推送服务 开启 Debug 打开 Debug 模式以后可以在终端看到详细的信鸽 Debug 信息，方便定位问题 示例 //打开debug开关 [[XGPush defaultManager] setEnableDebug:YES]; //查看debug开关是否打开 BOOL debugEnabled = [[XGPush defaultManager] isEnableDebug]; 启动信鸽推送服务 接口 - (void)startXGWithAppID:(uint32_t)appID appKey:(nonnull NSString *)appKey delegate:(nullable id)delegate ; 示例 [[XGPush defaultManager] startXGWithAppID:2200262432 appKey:@\"I89WTUY132GJ\" delegate:]; 终止信鸽推送服务 终止信鸽推送服务以后，将无法通过信鸽推送服务向设备推送消息 接口 - (void)stopXGNotification; 示例 [[XGPush defaultManager] stopXGNotification]; 统计推送效果 为了更好的了解每一条推送消息的运营效果，需要将用户对消息的行为上报 统计消息推送的抵达情况 需要在UIApplicationDelegate的回调方法(如下)中调用上报数据的接口 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions; 接口 - (void)reportXGNotificationInfo:(nonnull NSDictionary *)info; 示例 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [[XGPush defaultManager] reportXGNotificationInfo:launchOptions]; } 统计消息被点击情况 iOS 10 以前的系统版本，需要在 UIApplicationDelegate 的回调方法(如下)中调用上报数据的接口 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo; 接口 - (void)reportXGNotificationInfo:(nonnull NSDictionary *)info; 示例 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo { [[XGPush defaultManager] reportXGNotificationInfo:userInfo]; } iOS 10 or later 需要实现 XGPushDelegate 的回调方法(如下),并在其中调用上述上报接口 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler; 示例： - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler { [[XGPush defaultManager] reportXGNotificationInfo:response.notification.request.content.userInfo]; completionHandler() } 如果需要实现应用在前台时，也可以展示推送消息，需要实现以下方法，并在其中调用上报接口 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler 示例 - (void)xgPushUserNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler { [[XGPush defaultManager] reportXGNotificationInfo:notification.request.content.userInfo]; completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert); } 信鸽推送服务协议(XGPushDelegate) 设置信鸽推送协议代理对象是为了方便查看接口调用的情况，开发者可根据自己的需求选择实现协议的方法 协议方法如下： /** 处理iOS 10 UNUserNotification.framework的对应的方法 @param center [UNUserNotificationCenter currentNotificationCenter] @param notification 通知对象 @param completionHandler 回调对象，必须调用 */ - (void)xgPushUserNotificationCenter:(nonnull UNUserNotificationCenter *)center willPresentNotification:(nullable UNNotification *)notification withCompletionHandler:(nonnull void (^)(UNNotificationPresentationOptions options))completionHandler __IOS_AVAILABLE(10.0); /** 处理iOS 10 UNUserNotification.framework的对应的方法 @param center [UNUserNotificationCenter currentNotificationCenter] @param response 用户对通知消息的响应对象 @param completionHandler 回调对象，必须调用 */ - (void)xgPushUserNotificationCenter:(nonnull UNUserNotificationCenter *)center didReceiveNotificationResponse:(nullable UNNotificationResponse *)response withCompletionHandler:(nonnull void (^)(void))completionHandler __IOS_AVAILABLE(10.0); /** @brief 监控信鸽推送服务地启动情况 @param isSuccess 信鸽推送是否启动成功 @param error 信鸽推送启动错误的信息 */ - (void)xgPushDidFinishStart:(BOOL)isSuccess error:(nullable NSError *)error; /** @brief 监控信鸽服务的终止情况 @param isSuccess 信鸽推送是否终止 @param error 信鸽推动终止错误的信息 */ - (void)xgPushDidFinishStop:(BOOL)isSuccess error:(nullable NSError *)error; /** @brief 监控信鸽服务上报推送消息的情况 @param isSuccess 上报是否成功 @param error 上报失败的信息 */ - (void)xgPushDidReportNotification:(BOOL)isSuccess error:(nullable NSError *)error; 管理设备Token 注册设备token 启动推送服务以后,如果注册推送成功，则应用会调用UIApplicationDelegate代理对象的回调方法(如下)，开发者可以在其中调用注册设备token的接口(非必须) - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken; 接口 - (void)registerDeviceToken:(nonnull NSData *)deviceToken; 示例 - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken { [[XGPushTokenManager defaultTokenManager] registerDeviceToken:deviceToken]; } 绑定/解绑标签和账号 开发者可以针对不同的用户绑定标签,然后对该标签推送.对标签推送会让该标签下的所有设备都收到推送.一个设备可以绑定多个标签. 接口 - (void)bindWithIdentifier:(nullable NSString *)identifier type:(XGPushTokenBindType)type; - (void)unbindWithIdentifer:(nullable NSString *)identifier type:(XGPushTokenBindType)type; 示例 绑定标签： [[XGPushTokenManager defaultTokenManager] bindWithIdentifier:@\"your tag\" type:XGPushTokenBindTypeTag]; 解绑标签 [[XGPushTokenManager defaultTokenManager] unbindWithIdentifer:@\"your tag\" type:XGPushTokenBindTypeTag]; 绑定账号： [[XGPushTokenManager defaultTokenManager] bindWithIdentifier:@\"your account\" type:XGPushTokenBindTypeAccount]; 解绑账号： [[XGPushTokenManager defaultTokenManager] unbindWithIdentifer:@\"your account\" type:XGPushTokenBindTypeAccount]; 注1: 一个账号最多绑定15台设备,超过之后会随机解绑一台设备,然后再进行注册. 管理设备Token协议(XGPushTokenManagerDelegate) 设置设备token绑定协议代理对象是为了方便查看token绑定的结果，开发者可根据自己的需求选择实现协议的方法 示例 [[XGPushTokenManager defaultTokenManager].delegatge = ; 协议方法如下： /** @brief 监控token对象绑定的情况 @param identifier token对象绑定的标识 @param type token对象绑定的类型 @param error token对象绑定的结果信息 */ - (void)xgPushDidBindWithIdentifier:(nullable NSString *)identifier type:(XGPushTokenBindType)type error:(nullable NSError *)error; /** @brief 监控token对象解绑的情况 @param identifier token对象绑定的标识 @param type token对象绑定的类型 @param error token对象绑定的结果信息 */ - (void)xgPushDidUnbindWithIdentifier:(nullable NSString *)identifier type:(XGPushTokenBindType)type error:(nullable NSError *)error; 本地推送 本地推送相关功能请参考苹果开发者文档. "},"ios_access/ios-chang-jian-wen-ti-zi-cha.html":{"url":"ios_access/ios-chang-jian-wen-ti-zi-cha.html","title":"iOS 常见问题自查","keywords":"","body":"iOS常见问题自查 问：iOS是否支持离线保存 答：苹果默认支持离线保存1条消息。关于离线保存的时长苹果官方文档没有明确的说明。 问：为何每天看到的全量推送的实发量会有波动，有时高有时低 答：信鸽后台会根据每天推送时，apns返回的错误来清理已经过期的无效token。这个清理每天都会执行一次，因此第二天的全量推送实发量是已经除去了前一天的过期token的数量，可能会比前一天的实发量少。这是属于正常现象。 问：初始化信鸽接口，出现如下日志 2017-10-26 15:13:38.888951+0800 XG-Demo[2295:1737660] [xgpush] 服务器返回码: 20 答：在初始化信鸽的方法中 appid和appkey不要使用宏定义 问：什么情况会出现推送暂停 答：每小时最多可创建30条全量推送，超过30条的推送将被推送暂停 一小时内创建推送内容完全一样的推送，将被推送暂停 推送暂停的任务将不会下发，请视情况重新创建推送 问：上传证书到管理台失败 答：a）验证失败，请刷新后重试 >> 用编辑器打开证书文件，找到friendlyname字段如果同行有？‘，将其修改成别的，保存后重新上传。 b）不包含push参数 >> 制作新的推送证书 c）文件大小为0kb，不能上传 >> 重新转换pem格式 信鸽证书制作教程：https://v.qq.com/x/page/u0302fjna1h.html 问：终端出现\"Error Domain=NSCocoaErrorDomain Code=3000 \"未找到应用程序的“aps-environment”的授权字符串\" UserInfo=0x16545fc0 {NSLocalizedDescription=未找到应用程序的“aps-environment”的授权字符串}\"错误 答：这是由于app证书没有推送权限引起的.请重新配置证书 问：设备收到消息没有进入回调 答：iOS10会进静默通知的回调方法中 问：设置/删除标签的时候出现如下错误 exception.name= WupSerializableException exception.reason= -[XGJceOutputStream writeAnything:tag:required:], 349: assert(0) fail! 答：请在registerDevice之后再setTag/delTag.在registerDevice之前进行tag操作会出现这个错误 问：token和别名（account）的对应关系 答：一个设备一个token，token在注册推送时由苹果下发，一个token最多绑定一个account，一个account最多绑定15个token，超出数量时会顶替之前绑定的token。iOS的token是会变化的，卸载，重装，刷机，重置都会导致token发生变化。 问：创建推送成功了，但推送列表没有该条推送的记录 答：推送列表只展示针对所有设备和批量设备的推送记录 问：如何播放自定义通知音？ 答：把音频文件放到bundle目录下，创建推送时，给sound字段传入音频文件名称。 问：使用信鸽服务端sdk，怎么创建静默推送 答：给参数content-available赋值1，同时不使用setalert "},"server_api.html":{"url":"server_api.html","title":"服务端API接入","keywords":"","body":"服务端API接入 Rest API接入 服务端其他语言 "},"server_api/rest.html":{"url":"server_api/rest.html","title":"Rest API 使用指南","keywords":"","body":"Rest API 使用指南 协议描述 请求URL结构为： http://接口域名/v2/class/method?params 字段名 用途 备注 接口域名 接口域名 统一使用openapi.xg.qq.com v2 表示当前api的版本号 无 class 提供的接口类别 无 method 每个接口大类提供的具体操作接口 如查询、设置、删除等 params 以GET方式调用接口时传递的参数 包括通用参数和api相关特定参数。所有的参数都必须为utf8编码，params字符串应进行url encode 注：以POST方式调用接口时，参数应以POST参数形式传递，内容要求同params字段。HTTP HEADER中“Content-type”字段要设置为“application/x-www-form-urlencoded” 通用参数 各接口url结构的params字段有共同参数 参数名 类型 是否必要 参数描述 access_id uint 是 应用的唯一标识符，在提交应用时管理系统返回。可在xg.qq.com管理台查看 cal_type int 否 0-使用离线计算，1-使用实时统计，默认情况下为0 timestamp uint 是 本请求的unix时间戳，用于确认请求的有效期。默认情况下，请求时间戳与服务器时间（北京时间）偏差大于600秒则会被拒绝 valid_time uint 否 配合timestamp确定请求的有效期，单位为秒，最大值为600。若不设置此参数或参数值非法，则按默认值600秒计算有效期 sign string 是 内容签名 备注：内容签名生成规则： A）提取请求方法method（GET或POST）； B）提取请求url信息，包括Host字段的IP或域名和URI的path部分，注意不包括Host的端口和Path的querystring。请在请求中带上Host字段，否则将视为无效请求。比如openapi.xg.qq.com/v2/push/single_device或者10.198.18.239/v2/push/single_device; C）将请求参数（不包括sign参数）格式化成K=V方式，注意：计算sign时所有参数不应进行urlencode； D）将格式化后的参数以K的字典序升序排列，拼接在一起，注意字典序中大写字母在前； E）拼接请求方法、url、排序后格式化的字符串以及应用的secret_key； F）将E形成字符串计算MD5值，形成一个32位的十六进制（字母小写）字符串，即为本次请求sign（签名）的值； Sign=MD5($http_method$url$k1=$v1$k2=$v2$secret_key); 该签名值基本可以保证请求是合法者发送且参数没有被修改，但无法保证不被偷窥。 例如： POST请求到接口 http://openapi.xg.qq.com/v2/push/single_device，有四个参数，access_id=123，timestamp=1386691200，Param1=Value1，Param2=Value2，secret_key为abcde。 则上述E步骤拼接出的字符串为 POSTopenapi.xg.qq.com/v2/push/single_deviceaccess_id=123Param1=Value1Param2=Value2timestamp=1386691200abcde，注意字典序中大写在前。 计算出该字符串的MD5为6b90c7f4a137c7d0b756d48f748c93b2，以此作为sign参数的值 通用返回结果 { \"ret_code\":0, \"erroeMsg\":\"ok\" \"result\":{\"status\":0} } (1)字段定义如下 参数名 类型 是否必要 参数描述 ret_code int 是 返回码 err_msg string 否 请求出错时的错误信息 result json 否 请求正确时，若有额外数据要返回，则结果封装在该字段的json中。若无额外数据，则可能无此字段 特别注意： 1）参数和值都是大小写敏感，如没有特别注明，都是小写 2）所有的K和V须urlencode，避免里面有“&”或“=”之类字符影响解析 通用返回码 描述如下 值 含义 可采取措施 0 调用成功 -1 参数错误 检查参数配置 -2 请求时间戳不在有效期内 检查设备当前时间 -3 sign校验无效 检查Access ID和Secret Key（注意不是Access Key） 2 参数错误 检查参数配置 14 收到非法token，例如iOS终端没能拿到正确的token Android Token长度为40位iOS Token长度为64位 15 信鸽逻辑服务器繁忙 稍后重试 19 操作时序错误。例如进行tag操作前未获取到deviceToken 没有获取到deviceToken的原因：1.没有注册信鸽或者苹果推送2.provisioning profile制作不正确 20 鉴权错误，可能是由于Access ID和Access Key不匹配 检查Access ID和Access Key 40 推送的token没有在信鸽中注册 检查token是否注册 48 推送的账号没有绑定token 检查account和token是否有绑定关系见推送指南：绑定/设置账号见热门问题解答：账号和设备未绑定的解答 63 标签系统忙 检查标签是否设置成功见推送指南：设置标签 71 APNS服务器繁忙 苹果服务器繁忙，稍后重试 73 消息字符数超限 iOS目前是1000字节左右，苹果的额外推送设置如角标，也会占用字节数 76 请求过于频繁，请稍后再试 全量广播限频为每3秒一次 78 循环任务参数错误 100 APNS证书错误。请重新提交正确的证书 证书格式是pem的，另外，注意区分生产证书、开发证书的区别 其他 其他错误 推送Android平台 message参数值应为如下所述的json字符串，其总长度不能超过4096字节。 (1)推送通知定义示例（默认展示在手机或设备通知栏） {\"content\":\"this is content\",\"title\":\"this is title\", \"vibrate\":1} (2)完整定义 { \"title \":\"xxx\", // 标题，必填 \"content \":\"xxxxxxxxx\", // 内容，必填 \"accept_time\": //表示消息将在哪些时间段允许推送给用户，选填 [ { “start”:{“hour”:”13”,“min”:”00”}, ”end”: {“hour”:”14”,“min”:”00”} }, { “start”:{“hour”:”00”,”min”:”00”}, ”end”: {“hour”:”09”,“min”:”00”} } ], \"n_id\":0, //通知id，选填。若大于0，则会覆盖先前弹出的相同id通知；若为0，展示本条通知且不影响其他通知；若为-1，将清除先前弹出的所有通知，仅展示本条通知。默认为0 \"builder_id\":0, // 本地通知样式，必填 \"ring\":1， // 是否响铃，0否，1是，下同。选填，默认1 \"ring_raw\":\"ring\", // 指定应用内的声音（ring.mp3），选填 \"vibrate\":1, // 是否振动，选填，默认1 \"lights\":1// 是否呼吸灯，0否，1是，选填，默认1 \"clearable\":1, // 通知栏是否可清除，选填，默认1 \"icon_type\":0 //默认0，通知栏图标是应用内图标还是上传图标,0是应用内图标，1是上传图标,选填 \"icon_res\":\"xg\",// 应用内图标文件名（xg.png）或者下载图标的url地址，选填 \"style_id\":1 //Web端设置是否覆盖编号的通知样式，默认1，0否，1是,选填 \"small_icon\":\"xg\"指定状态栏的小图片(xg.png),选填 \"action\":{ // 动作，选填。默认为打开app \"action_type \": 1, // 动作类型，1打开activity或app本身，2打开浏览器，3打开Intent \"activity \": \"xxx\" \"aty_attr \": // activity属性，只针对action_type=1的情况 { \"if\":0, // 创建通知时，intent的属性，如：intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED); \"pf\":0, // PendingIntent的属性，如：PendingIntent.FLAG_UPDATE_CURRENT } \"browser\": {\"url\": \"xxxx \",\"confirm\": 1}, // url：打开的url，confirm是否需要用户确认 “intent”: “xxx” }, \"custom_content\":{ // 用户自定义的key-value，选填 \"key1\": \"value1\", \"key2\": \"value2\" } } (3)透传消息定义示例（可以由app识别的任意透传消息命令，比推送通知更灵活） {\"content\":\"this is content\",\"title\":\"this is title\"} (4)完整定义 { \"title\":\"xxx\", // 标题，选填 \"content \":\"xxxxxxxxx\", // 内容，选填 \"accept_time\": //表示消息将在哪些时间段允许推送给用户，选填 [ { “start”:{“hour”:”13”,“min”:”00”}, ”end”: {“hour”:”14”,“min”:”00”} }, { “start”:{“hour”:”00”,”min”:”00”}, ”end”: {“hour”:”09”,“min”:”00”} } ], \"custom_content\":{ // 用户自定义的key-value，选填 \"key1\": \"value1\", \"key2\": \"value2\" } } 推送iOS平台 message参数应为APNS规定的payload（也是一个json字符串），详细定义参考APNS官方手册。 信鸽在其基础上仅增添了两保留字段 xg 和 accept_time。payload不能超过800字节。需要注意的是accept_time字段不会传递给APNS，因此不占用payload容量。 (1)普通通知示例 { \"aps\" : { // apns规定的key-value \"alert\" : { //设置消息通知栏的字段 \"title\": \"this is a title\", //通知标题 \"body\" : \"Bob wants to play poker\", //通知内容 }, \"badge\" : 5, “category” : “INVITE_CATEGORY”, }, \"accept_time\":[ //允许推送给用户的时段，选填。accept_time不会占用payload容量 { \"start\":{\"hour\":\"13\",\"min\":\"00\"}, \"end\": {\"hour\":\"14\",\"min\":\"00\"} }, { \"start\":{\"hour\":\"00\",\"min\":\"00\"}, \"end\": {\"hour\":\"09\",\"min\":\"00\"} } ] // 仅0~9点和13~14点这两个时段可推送 \"custom1\" : \"bar\", // 合法的自定义key-value，会传递给app \"custom2\" : [ \"bang\", \"whiz\" ], // 合法的自定义key-value，会传递给app \"xg\" : \"oops\" // 错误！xg为信鸽系统保留key，其value会被信鸽系统覆盖，应避免使用 } (2)静默通知示例 { \"aps\" : { // apns规定的key-value \"badge\" : 5, \"category\" : “INVITE_CATEGORY”, \"content-available\": 1, //静默通知的标识 }, \"custom1\" : \"bar\", // 合法的自定义key-value，会传递给app \"custom2\" : [ \"bang\", \"whiz\" ], // 合法的自定义key-value，会传递给app \"xg\" : \"oops\" // 错误！xg为信鸽系统保留key，其value会被信鸽系统覆盖，应避免使用 } 推送接口 单个设备 url路径 http://接口域名/v2/push/single_device?params 请求参数：除了通用参数外，还包括如下参数 参数说明 参数名 类型 必需 默认值 描述 device_token string 是 无 针对某一设备推送，token是设备的唯一识别 ID message_type uint 是 无 消息类型：1：通知 2：透传消息。iOS平台请填0 message string 是 无 参见1.1.4、1.1.5两节 expire_time uint 否 3天 消息离线存储时间（单位为秒），最长存储时间3天。若设置为0，则使用默认值（3天） send_time string 否 立即 指定推送时间，格式为year-mon-day hour:min:sec 若小于服务器当前时间，则会立即推送 multi_pkg uint 否 0 0表示按注册时提供的包名分发消息；1表示按access id分发消息，所有以该access id成功注册推送的app均可收到消息。本字段对iOS平台无效 environment uint 仅iOS必需 无 向iOS设备推送时必填，1表示推送生产环境；2表示推送开发环境。推送Android平台不填或填0 响应结果：在通用返回结果参数中，result字段的json为空。 返回：本接口不返回push id 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/push/single_deviceaccess_id=2100250470device_token=76501cd0277cdcef4d8499784a819d4772e0fddemessage={\"title\":\"测试消息\",\"content\":\"来自restapi的单推接口测试消息\"}message_type=1timestamp=1502356505f1fa8b11f540794bf13e10d499ac5c36 RestApi Url: http://openapi.xg.qq.com/v2/push/single_device?access_id=2100250470&timestamp=1502356505&device_token=76501cd0277cdcef4d8499784a819d4772e0fdde&message_type=1&message={\"title\":\"测试消息\",\"content\":\"来自restapi的单推接口测试消息\"}&sign=b7f5761d37fb352536e53db0c50ffcc6 批量设备 首先，需要创建批量消息 url路径 http://接口域名/v2/push/create_multipush?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 message_type uint 是 无 消息类型：1：通知 2：透传消息 message string 是 无 参见1.1.4、1.1.5两节 expire_time uint 否 3天 消息离线存储时间（单位为秒），最长存储时间3天。若设置为0，则不存储；iOS无需设置此参数 multi_pkg uint 否 无 0表示按注册时提供的包名分发消息；1表示按access id分发消息，所有以该access id成功注册推送的app均可收到消息 environment uint 仅iOS必需 无 向iOS设备推送时必填，1表示推送生产环境；2表示推送开发环境。推送Android平台不填或填0 响应结果：在通用返回结果参数中，result字段的json如下 { “push_id”:string (表示给app下发的任务id) } 其次，按照已创建的批量推送消息推送给多个设备 url路径 http://接口域名/v2/push/device_list_multiple?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 device_list string 是 无 Json数组格式，每个元素是一个token，string类型，单次发送token不超过1000个。例：[“token1”,”token2”,”token3”] push_id uint 是 无 创建批量推送消息 接口的返回值中的 push_id 响应结果：在通用返回结果参数中，result字段的json为空 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） 获取push_id： MD5加密前： GETopenapi.xg.qq.com/v2/push/create_multipushaccess_id=2100264266message={\"title\":\"测试消息\",\"content\":\"来自restapi的批量接口测试消息\",\"custom_content\":{\"key1\":\"value1\",\"key2\":\"value2\"}}message_type=2timestamp=1502694940d8fc29c627259a06452794e31dab5bb8 RestApi Url: http://openapi.xg.qq.com/v2/push/create_multipush?access_id=2100264266&message={\"title\":\"测试消息\",\"content\":\"来自restapi的批量接口测试消息\",\"custom_content\":{\"key1\":\"value1\",\"key2\":\"value2\"}}&message_type=2&timestamp=1502694940&sign=e5ca158c01712fb185399e67b6a57d1f 进行推送： MD5加密前： GETopenapi.xg.qq.com/v2/push/device_list_multipleaccess_id=2100264266device_list=[\"78e8540853619eb14fb49fdd53274c0c82ca2025\"]push_id=2854657652timestamp=1502694940d8fc29c627259a06452794e31dab5bb8 RestApi Url: http://openapi.xg.qq.com/v2/push/device_list_multiple?access_id=2100264266&device_list=[\"78e8540853619eb14fb49fdd53274c0c82ca2025\"]&push_id=2854657652&timestamp=1502694940&sign=e4779a9173a1c51541800e76b8a25322 全量设备 后台对本接口的调用频率有限制，两次调用之间的时间间隔不能小于3秒。 url路径 http://接口域名/v2/push/all_device?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 message_type uint 是 无 消息类型：1：通知 2：透传消息。iOS平台请填0 message string 是 参见1.1.4、1.1.5两节 expire_time uint 否 3天 消息离线存储时间（单位为秒），最长存储时间3天。若设置为0，则使用默认值（3天） send_time string 否 立即 指定推送时间,格式为year-mon-day hour:min:sec 若小于服务器当前时间，则会立即推送 multi_pkg uint 否 0 0表示按注册时提供的包名分发消息；1表示按access id分发消息，所有以该access id成功注册推送的app均可收到消息。本字段对iOS平台无效 environment uint 仅iOS必需 向iOS设备推送时必填，1表示推送生产环境；2表示推送开发环境。推送Android平台不填或填0 loop_times uint 否 循环任务执行的次数，取值[1, 15] loop_interval uint 否 循环任务的执行间隔，以天为单位，取值[1, 14]。loop_times和loop_interval一起表示任务的生命周期，不可超过14天 响应结果：在通用返回结果参数中，result字段的json示例如下 { “push_id”:string (表示给app下发的任务id，如果是循环任务，返回的是循环父任务id) } 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/push/all_deviceaccess_id=2100240957message={\"title\":\"测试消息\",\"content\":\"来自restapi的全量接口测试消息\"}message_type=1timestamp=1502360486f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/push/all_device?access_id=2100240957&message={\"title\":\"测试消息\",\"content\":\"来自restapi的全量接口测试消息\"}&message_type=1&timestamp=1502360486&sign=4813a111880885223b72229495508813 标签 可以针对设置过标签的设备进行推送。如：女、大学生、低消费等任意类型标签。 标签推送url路径 http://接口域名/v2/push/tags_device?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 message string 是 无 参见1.1.4、1.1.5两节 message_type uint 是 1 消息类型：1：通知 2：透传消息。iOS平台请填0 tags_list json 是 无 [“tag1”,”tag2”,”tag3”] tags_op string 是 无 取值为AND或OR expire_time uint 否 3天 消息离线存储时间（单位为秒），最长存储时间3天。若设置为0，则使用默认值（3天） send_time string 否 立即 指定推送时间，格式为year-mon-day hour:min:sec 若小于服务器当前时间，则会立即推送 multi_pkg uint 否 0 0表示按注册时提供的包名分发消息；1表示按access id分发消息，所有以该access id成功注册推送的app均可收到消息。本字段对iOS平台无效 environment uint 仅iOS必需 无 向iOS设备推送时必填，1表示推送生产环境；2表示推送开发环境。推送Android平台不填或填0 loop_times uint 否 无 循环任务执行的次数，取值[1, 15] loop_interval uint 否 无 循环任务的执行间隔，以天为单位，取值[1, 14]。loop_times和loop_interval一起表示任务的生命周期，不可超过14天 响应结果：在通用返回结果参数中，result字段的json示例如下 { “push_id”:string (表示给app下发的任务id，如果是循环任务，返回的是循环父任务id) } 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/push/tags_deviceaccess_id=2100240957message={\"title\":\"测试消息\",\"content\":\"来自restapi的标签接口测试消息\"}message_type=1tags_list=[\"qwertyuiop\"]tags_op=ORtimestamp=1502360486f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/push/tags_device?access_id=2100240957&message={\"title\":\"测试消息\",\"content\":\"来自restapi的标签接口测试消息\"}&message_type=1&timestamp=1502360486&tags_list=[\"qwertyuiop\"]&tags_op=OR&sign=95dbc4d1107a99d6824fda19e7ff09c9 单个帐号 设备的账户或别名由终端SDK在调用推送注册接口时设置，详情参考终端SDK文档。 url路径 http://接口域名/v2/push/single_account?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 account string 是 无 针对某一账号推送，帐号可以是qq号，邮箱号，openid，手机号等各种类型 message_type uint 是 1 消息类型：1：通知 2：透传消息 message string 是 无 参见1.1.4、1.1.5两节 expire_time uint 否 3天 消息离线存储时间（单位为秒），最长存储时间3天。若设置为0，则使用默认值（3天） send_time string 否 立即 指定推送时间，格式为year-mon-day hour:min:sec 若小于服务器当前时间，则会立即推送 multi_pkg uint 否 0 0表示按注册时提供的包名分发消息；1表示按access id分发消息，所有以该access id成功注册推送的app均可收到消息 environment uint 仅iOS必需 无 向iOS设备推送时必填，1表示推送生产环境；2表示推送开发环境。推送Android平台不填或填0 响应结果：在通用返回结果参数中，result字段的json为空。本接口不返回push id 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/push/single_accountaccess_id=2100240957account=easonshipushtestaccountmessage={\"title\":\"测试消息\",\"content\":\"来自restapi的单个账号接口测试消息\"}message_type=1timestamp=1502361241f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/push/single_account?access_id=2100240957&account=easonshipushtestaccount&message={\"title\":\"测试消息\",\"content\":\"来自restapi的单个账号接口测试消息\"}&message_type=1&timestamp=1502361241&sign=0d7bee840e87801e8a90b831ee87eefb 批量帐号 设备的账户或别名由终端SDK在调用推送注册接口时设置，详情参考终端SDK文档。 url路径 http://接口域名/v2/push/account_list?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 account_list string 是 无 Json数组格式，每个元素是一个account，string类型，单次发送account不超过100个。例：[“account1”,”account2”,”account3”] message_type uint 是 无 消息类型：1：通知 2：透传消息 message string 是 无 参见1.1.4、1.1.5两节 expire_time uint 否 3天 消息离线存储时间（单位为秒），最长存储时间3天。若设置为0，则使用默认值（3天） multi_pkg uint 否 0 0表示按注册时提供的包名分发消息；1表示按access id分发消息，所有以该access id成功注册推送的app均可收到消息 environment uint 仅iOS必需 无 向iOS设备推送时必填，1表示推送生产环境；2表示推送开发环境。推送Android平台不填或填0 响应结果：在通用返回结果参数中，result字段的json为每个account发送返回码。本接口不返回push id 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/push/account_listaccess_id=2100240957account_list=[\"easonshipushtestaccount\"]message={\"title\":\"测试消息\",\"content\":\"来自restapi的批量账号接口测试消息\"}message_type=1timestamp=1502361241f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/push/account_list?access_id=2100240957&account_list=[\"easonshipushtestaccount\"]&message={\"title\":\"测试消息\",\"content\":\"来自restapi的批量账号接口测试消息\"}&message_type=1&timestamp=1502361241&sign=cff802738763385db89aaadb49dbe345 注： 如果推送目标帐号数量很大（比如≥10000），推荐使用account_list_multiple接口，用户请自行比较异同 首先，（如同推送批量设备）需要创建批量消息： url路径 http://接口域名/v2/push/create_multipush?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 message_type uint 是 无 消息类型：1：通知 2：透传消息 message string 是 无 参见1.1.4、1.1.5两节 expire_time uint 否 无 消息离线存储多久，单位为秒，最长存储时间3天。在超时时间内，可以发起此消息的批量推送 multi_pkg uint 否 无 0表示按注册时提供的包名分发消息；1表示按access id分发消息，所有以该access id成功注册推送的app均可收到消息 environment uint 仅iOS必需 无 向iOS设备推送时必填，1表示推送生产环境；2表示推送开发环境。推送Android平台不填或填0 其次，选择推送批量帐号： url路径 http://接口域名/v2/push/account_list_multiple?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 account_list string 是 无 Json数组格式，每个元素是一个account，string类型，单次发送account不超过1000个。例：[“account1”,”account2”,”account3”] push_id uint 是 无 创建批量推送消息 接口的返回值中的 push_id 响应结果：在通用返回结果参数中，result字段的json为空 示例：请参考批量设备示例 标签设置/删除接口 (1)批量设置标签 url路径 http://接口域名/v2/tags/batch_set 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 tag_token_list string 是 无 json字符串，包含若干标签-token对，后台将把每一对里面的token打上对应的标签。每次调用最多允许设置20对，每个对里面标签在前，token在后。注意标签最长50字节，不可包含空格；真实token长度至少40字节。示例（其中token值仅为示意）： [[”tag1”,”token1”],[”tag2”,”token2”]] 响应结果：在通用返回结果参数中，result字段的json为空 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/tags/batch_setaccess_id=2100240957tag_token_list=[[\"easonshitag1\",\"76501cd0277cdcef4d8499784a819d4772e0fdde\"]]timestamp=1502361905f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/tags/batch_set?access_id=2100240957&tag_token_list=[[\"easonshitag1\",\"76501cd0277cdcef4d8499784a819d4772e0fdde\"]]&timestamp=1502361905&sign=3c0ea17401f02fed8397eef9230fb607 (2)批量删除标签 url路径 http://接口域名/v2/tags/batch_del 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 tag_token_list string 是 无 json字符串，包含若干标签-token对，后台将为每一对里面的token删除对应的标签。每次调用最多允许设置20对，每个对里面标签在前，token在后。注意标签最长50字节，不可包含空格；真实token长度至少40字节。示例如下（其中token值仅为示意）： [[”tag1”,”token1”],[”tag2”,”token2”]] 响应结果：在通用返回结果参数中，result字段的json为空 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/tags/batch_delaccess_id=2100240957tag_token_list=[[\"easonshitag1\",\"76501cd0277cdcef4d8499784a819d4772e0fdde\"]]timestamp=1502361905f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/tags/batch_del?access_id=2100240957&tag_token_list=[[\"easonshitag1\",\"76501cd0277cdcef4d8499784a819d4772e0fdde\"]]&timestamp=1502361905&sign=301fd2e83a7f65223e1d9e38fb0b5864 账号映射删除接口 单清 (1)删除应用中某个account映射的某个token url路径 http://接口域名/v2/application/del_app_account_tokens?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 account string 是 无 账号，可以是邮箱号、手机号、QQ号等任意形式的业务帐号 device_token string 是 无 token，设备的唯一识别ID 响应结果：在通用返回结果参数中，result字段的json如下 { “tokens”:[“token1”,”token2”] } 即显示删除device_token后该account映射的剩余token 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/application/del_app_account_tokensaccess_id=2100240957account=easonshipushtestaccountdevice_token=76501cd0277cdcef4d8499784a819d4772e0fddetimestamp=1502361905f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/application/del_app_account_tokens?access_id=2100240957&account=easonshipushtestaccount&device_token=76501cd0277cdcef4d8499784a819d4772e0fdde&timestamp=1502361905&sign=c8c86feab7a1d8b1a3064c733a76079a 全清 (1)删除应用中某account映射的所有token url路径 http://接口域名/v2/application/del_app_account_all_tokens?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 account string 是 无 账号 响应结果：在通用返回结果参数中，result字段的json为空 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/application/del_app_account_all_tokensaccess_id=2100240957account=easonshipushtestaccounttimestamp=1502701471f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/application/del_app_account_all_tokens?access_id=2100240957&account=easonshipushtestaccount&timestamp=1502701471&sign=88fbcc8b5c29a3f5ae1dab99b7479439 查询接口 查询消息/设备/帐号 (1)查询群发消息发送状态 url路径 http://接口域名/v2/push/get_msg_status?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 push_id json 是 [ {“push_id”: string}, {“push_id”:“xxxx”}, ] | 响应结果：在通用返回结果参数中，result字段的json形式为： { “list”: [ { “push_id”: “27ABC5486977” “status”: 0（未处理）/1（推送中）/2（推送完成）/3（推送失败） “start_time”:”year-mon-day hour:min:sec“ “finished”:xxxx （已发送） “total”:xxxxx （共需要发送） }, ] } 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/push/get_msg_statusaccess_id=2100240957push_id=2841253998timestamp=1502698593f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/push/get_msg_status?access_id=2100240957&push_id=2841253998&timestamp=1502698593&sign=39b62ab54f08e7844ed1d86e00cec76a (2)查询应用覆盖的设备数（token总数） url路径 http://接口域名/v2/application/get_app_device_num?params 请求参数：本接口仅包括公共参数 响应结果：在通用返回结果参数中，result字段的json形式为： { “device_num”: 34567(设备数) } 若请求应用列表中某个应用信息非法，则不会在result中返回结果 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/application/get_app_device_numaccess_id=2100240957timestamp=1502701471f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/application/get_app_device_num?access_id=2100240957&timestamp=1502701471&sign=e4385f856ddaa932170c181927965cb1 (3)查询应用的某个token的信息（查看是否有效） url路径 http://接口域名/v2/application/get_app_token_info?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 device_token string 是 无 无 响应结果：在通用返回结果参数中，result字段的json如下： { \"isReg\":1,（1为token已注册，0为未注册） \"connTimestamp\":1426493097, （最新活跃时间戳） \"msgsNum\":2（该应用的离线消息数） } 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/application/get_app_token_infoaccess_id=2100240957device_token=76501cd0277cdcef4d8499784a819d4772e0fddetimestamp=1502698593f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/application/get_app_token_info?access_id=2100240957&device_token=76501cd0277cdcef4d8499784a819d4772e0fdde&timestamp=1502698593&sign=c4f650c6c468adba2e2b82a15ca68c3e (4)查询应用某帐号映射的token（查看帐号-token对应关系） url路径 http://接口域名/v2/application/get_app_account_tokens?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 account string 是 无 帐号 响应结果：在通用返回结果参数中，result字段的json如下 { “tokens”:[“token1”,”token2”] } 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/application/get_app_account_tokensaccess_id=2100240957account=easonshipushtestaccounttimestamp=1502699212f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/application/get_app_account_tokens?access_id=2100240957&account=easonshipushtestaccount&timestamp=1502699212&sign=015ef9e7fde208f2d12674f731e13e8c 查询标签 (1)查询应用设置的标签 url路径 http://接口域名/v2/tags/query_app_tags?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 start uint 否 0 开始值 limit uint 否 100 限制数量 响应结果：在通用返回结果参数中，result字段的json格式如下 { “total”: 2, //应用的tag总数，注意不是本次查询返回的tag数 “tags”:[“tag1”,”tag2”] } 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/tags/query_app_tagsaccess_id=2100240957timestamp=1502699212f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/tags/query_app_tags?access_id=2100240957&timestamp=1502699212&sign=5dbf914884378af6b62cba919e012b34 (2)查询应用的某个设备上设置的标签 url路径 http://接口域名/v2/tags/query_token_tags?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 device_token string 是 无 无 响应结果：在通用返回结果参数中，result字段的json格式如下 { “tags”:[“tag1”,”tag2”] } 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/tags/query_token_tagsaccess_id=2100240957device_token=76501cd0277cdcef4d8499784a819d4772e0fddetimestamp=1502699212f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/tags/query_token_tags?access_id=2100240957&device_token=76501cd0277cdcef4d8499784a819d4772e0fdde&timestamp=1502699212&sign=4cbd1b7a5553ed263f47a4a0b96402e9 (3)查询应用某个标签下关联的设备数 url路径 http://接口域名/v2/tags/ query_tag_token_num?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 tag string 是 无 无 响应结果：在通用返回结果参数中，result字段的json格式如下 { “device_num”:589874 } 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/tags/query_tag_token_numaccess_id=2100240957tag=easonmipushtesttimestamp=1502699920f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/tags/query_tag_token_num?access_id=2100240957&tag=easonmipushtest&timestamp=1502699920&sign=0ea7f16df1b59d69c9b81b385f938822 查询SDK版本号 接口定义：查询app内信鸽的SDK版本。该接口为终端接口。 Android： com.tencent.android.tpush.common.Constants.PUSH_SDK_VERSION iOS： XGSetting.h里面的XG_SDK_VERSION宏 任务删除/取消接口 (1)删除群发推送任务的离线消息 后悔药，针对有任务ID（push ID），并且已发送任务可以删除离线消息 注意：该功能仅支持在管理台使用，点击“停止”按钮即可 (2)取消尚未触发的定时群发任务 后悔药，针对尚未发送的任务，需要任务ID url路径 http://接口域名/v2/push/cancel_timing_task?params 请求参数：除了通用参数外，还包括如下参数 参数名 类型 必需 默认值 描述 push_id string 是 无 要取消的任务ID 响应结果：在通用返回结果参数中，result字段的json格式如下 { “status”: 0, //0为成功，其余为失败 } 示例：MD5加密前url用作生成sign，RestApi Url为最终请求的url（以下为android推送示例，需替换通用参数后使用） MD5加密前： GETopenapi.xg.qq.com/v2/push/cancel_timing_taskaccess_id=2100240957push_id=2853333945timestamp=1502700856f255184d160bad51b88c31627bbd9530 RestApi Url: http://openapi.xg.qq.com/v2/push/cancel_timing_task?access_id=2100240957&push_id=2853333945&timestamp=1502700856&sign=1fb3b7846f79d0027542acd05effb4a3 "},"server_api/other.html":{"url":"server_api/other.html","title":"服务端其他语言","keywords":"","body":"服务端其它语言 服务端其它语言SDK及文档官方下载： 1、服务端Java 2、服务端PHP 3、服务端Python 4、服务端C# 另外，感谢第三方开发者（非官方）提供的其它语言版本： 服务端Node js "},"push_ret_code.html":{"url":"push_ret_code.html","title":"信鸽返回码一览","keywords":"","body":"服务端返回码 值 含义 可采取措施 0 调用成功 -1 参数错误 检查参数配置 -2 请求时间戳不在有效期内 检查设备当前时间 -3 recv失败 稍后重试 -5 Action处理超时 稍后重试 2 非法参数 检查参数配置 5 与CMEM通讯失败 稍后重试（推送超时） 6 设备token未成功注册 请检查终端设备注册是否成功 7 通用错误，账号超限 删除其他未使用的账号(调用账号解绑） 14 token非法 Android Token长度为40位，iOS Token长度为64位 15 信鸽逻辑服务器繁忙 稍后重试 16 系统繁忙 稍后重试 19 操作时序错误。例如进行tag操作前未获取到deviceToken 没有获取到deviceToken的原因：1.没有注册信鸽或者苹果推送2.provisioning profile制作不正确 20 鉴权错误，可能是由于Access ID和Access Key不匹配 检查Access ID和Access Key（注意空格） 21 鉴权失败 检查Access ID和Access Key 40 推送的token没有在信鸽中注册 检查token是否注册 48 推送的账号没有绑定token 检查account和token是否有绑定关系见推送指南：绑定/设置账号见热门问题解答：账号和设备未绑定的解答 53 设备未注册 反注册后重新注册 73 消息字符数超限 iOS目前是1000字节左右，苹果的额外推送设置如角标，也会占用字节数 75 消息体格式不符合json格式 检查消息体即message字段内容 76 请求过于频繁，请稍后再试 全量广播限频为每3秒一次 78 循环任务参数错误 检查loop time 90 设备离线 重新打开应用 91 设备tag过多 清理不使用的tag 92 apptag过多 清理不使用的tag 100 APNS证书错误，请重新提交正确的证书 证书格式是pem的，另外，注意区分生产证书、开发证书的区别 -101 参数错误 请检查参数 -102 请求timestamp字段超过了时间过期 请使用当前系统时间戳，确保时间同步 -103 sign 不合法 检查签名生成流程，生成sign是METHOD 必须与请求时所使用的一致 -105 请求过于频繁 稍后重试 -106 证书错误 证书错误 -111 缺少公共参数：access_id\\timestamp\\sign 检查公共参数access_id\\timestamp\\sign -112 参数取值非法 检查参数取值 其他 信鸽内部错误 稍后重试，如出现为标明且必现错误请及时与我们取得联系 客户端返回码 值 原因以及解决办法 0 调用成功 2 参数错误，例如绑定了单字符的别名，或是ios的token长度不对，应为64个字符 20 鉴权错误,access id 或者 access key 配置错误 10000 起始错误 10001 操作类型错误码，例如参数错误时将会发生该错误 10002 正在执行注册操作时，又有一个注册操作到来，则回调此错误码 10003 权限配错或者缺少所需权限 10004 so库没有正确导入（Androidstudio可在main文件目录下 添加jniLibs命名的文件夹将SDK文档中的Other-Platform-SO下的7个so库文件夹添加至该目录） 10005 AndroidManifest文件的XGRemoteService节点没有配置或者的该节点的action包名配错 10008 jce JAR错误或者缺少 jce JAR（如果是混淆打包过后出现,请检查混淆代码） 10101 创建链路失败（切换网络重试） 10102 请求处理过程中， 链路被主动关闭（切换网络重试） 10103 请求处理过程中，服务器关闭链接（切换网络重试） 10104 请求处理过程中，客户端产生异常（切换网络重试） 10105 请求处理过程中，发送或接收报文超时（切换网络重试） 10106 请求处理过程中， 等待发送请求超时（切换网络重试） 10107 请求处理过程中， 等待接收请求超时（切换网络重试） 10108 服务器返回异常报文 10109 未知异常，切换网络 或者 重启设备） 10110 创建链路的handler为null 其他 如出现其他未知错误 请记录错误日志 与我们取得联系 "},"push_faq.html":{"url":"push_faq.html","title":"热门问题与解答","keywords":"","body":"热门问题与解答 为了帮助开发者提高集成效率，在热门问题与解答中，提供了推送集成流程，推送失败原因介绍，推送后台名词介绍以及热门技术问题。开发者可根据需要自行选择对应模块。 推送流程图 推送失败原因 热门技术问题 名词解释 权限说明 "},"push_faq/flow_chart.html":{"url":"push_faq/flow_chart.html","title":"推送流程图","keywords":"","body":"消息推送流程图 "},"push_faq/failure_reason.html":{"url":"push_faq/failure_reason.html","title":"推送失败原因","keywords":"","body":"推送失败原因 设备注册失败 新创建的app会有一分钟左右的数据同步过程，在此期间注册可能返回20错误码，稍后重试即可。其他情况返回20错误码，请检查access id和access key是否正确配置，常见错误是误用secret key或者access key头尾有空格。 帐号和设备未绑定 对于希望根据帐号进行推送的用户，首先需要将账号与token进行绑定，否则将无法推送成功。 注意： Android Token长度为40位 iOS Token长度为64位 账号，又称别名，指带有账号登录功能的APP的用户账号，这里不仅仅是QQ或微信，只要是用户的账号都支持，比如手机QQ的账号就是QQ号码，gmail的账号就是邮箱，中国移动的账号就是手机号码。 Android绑定账号在注册时绑定，即：registerPush(context,account)接口，ios通过setAccount设置。 选择帐号推送时，提示token not found,check registration，说明账号没和token关联上，这种情况有两种可能： (1)账号或别名注销了，不一定是app调用，某些情况下可能会自动触发注销的 (2)该设备注册了别的账号或别名，这样会自动与原来的解绑。（一个设备只能对应一个别名如果当前别名下没有设备了，就not found了） 绑定账号后，可以通过指定别名（账号）下发通知。通常情况下，这个账号最近登陆过的设备都可以收到通知。用户账号退出时，调用registerPush(context,\"*\")解除当前账号的绑定。 账号（别名）不允许单字符，一个token只能绑定一个账号，多次绑定时，以最后一次为准。 注意：一个帐号（即别名，account）下面最多可以绑定15台设备，当绑定满后，最新绑定的设备会随机顶掉之前绑定的一台设备token。 Service被终止 service被终止后，由系统、安全软件和用户操作限定是否能够再次启动。 信鸽SDK通过唯一的service与信鸽后台保持通讯，在android中，service被杀死后在没有被系统/安全软件禁止的条件下是能够自启动的，具体可自行网上搜索“android service onstartcommand START_STICKY” 目前，在某些定制的系统（如MIUI）或被安全软件禁止自启动后，只有用户再次打开APP才能重启信鸽service 信鸽service何时能够启动由系统调度确定 在锁屏触屏、网络切换、安装APP、系统重启等条件，信鸽会主动尝试启动service iOS证书问题 iOS推送提示failed to load certificate,check your APNS certificate，对应环境的apns证书没提交。 证书做得不对，请参照官方指南进行制作。 推送环境是否选择正确，测试预览请选择开发环境。 推送环境是否选择正确，开发证书对应测试环境，生产证书对应正式环境。 证书有效期判断 查看连接APNS测试证书是否合法 开发环境 生产环境 消息延时 在Android平台下，推送服务和大多数互联网服务一样，受限于包括网络服务质量、运营商政策或用户需求差异等因素的影响，所以有可能出现延时。另外，如果终端上信鸽service被系统或者安全软件杀死，也会有收不到或延时情况。 在iOS平台下，信鸽负责将消息成功转发给APNS，但APNS是否会成功下发给用户，具体下发多少，折损多少，都受限于包括网络服务质量、运营商政策等因素的影响。 注意：APNS只为离线终端保存一条消息，所以离线终端上线后仅能收到离线期间最新的一条消息。 排查方法 (1)设备是否正常联网？ (2)accessId、accessKey设置是否与前台注册的一致？ (3)当前APP包名是否与前台注册的一致？如果不一致，请在前台选中“使用多包名”选项。 (4)设备是否注册成功？ (5)前台下发通知时，“时段控制”选项里的时间段是否符合终端设备当前时间？ (6)请检查xml的receiver和service标签是否匹配，强烈建议请直接复制demo的例子再修改。 (7)请检查是否没有加“android.permission.GET_TASKS”权限的问题 推送暂停 （1）相同的内容在推送给所有设备的时候，一小时内不能重复创建。 （2）每小时最多创建30条全量推送。 "},"push_faq/technical_issues.html":{"url":"push_faq/technical_issues.html","title":"热门技术问题","keywords":"","body":"热门技术问题 Android平台 （1）多行显示 Android多行显示特性，在2.38及以上版本已经实现并默认开启。 主要的代码如下所示,请在你的工程内搜索并确认： NotificationCompat.BigTextStyle bigText = new NotificationCompat.BigTextStyle(); bigText.bigText(this.tickerText); build.setStyle(bigText); （2）多包名推送 目前市场上部分app针对不同渠道有不同的包名，同一款app可能会有上百个包名，这时就可以利用access id向该app的所有包名进行推送。在多包名推送模式下，设备上所有使用这个access id注册推送的app都会收到这条消息。 单应用多包名推送分为简单的三个步骤： a）在信鸽前台注册应用，无需填写包名；若已经填好包名，也不会影响推送效果； b）集成最新SDK在应用内； c）在进行推送前，将推送参数 multi_pkg 设置为1； (3)出现下列情况？ android.app.IntentReceiverLeaked: Activity com.xxxx has leaked IntentReceiver com.tencent.android.tpush.f@422a4dc8 that was originally registered here. Are you missing a call to unregisterReceiver()? 原因：acitvity在信鸽注册返回前就finish了，导致信鸽注册的receiver没有被取消 处理方法：registerPush传递的context改为context.getApplicationContext() （4）如何删除注册成功的Toast提示? 原因：demo里面的CustomPushReceiver自带Toast提示 处理方法：删除CustomPushReceiver里面的Toast相关内容 （5）libs目录下有很多平台的.so文件，如armabi、x86 原因：信鸽针对android所有的平台开发了.so库 处理方法：可以将不需要的平台目录删除掉，如游戏一般只有armabi，可以删除其它目录。 （6）指定打开某个activity页面，但经常不能正常跳转 原因：在部分手机，通知栏跳转到某个页面可能会出现权限问题 处理方法：在androidManifest.xml中，需要打开的activity加上android:exported=\"true\"。 （7）没有sd卡就不能用信鸽了么? 解答：不会，只是日志写的地方不同。 （8）注册方法能不能放到线程里创建，能不能在APPLICATON onCreate里就创建? 解答：注册方法可以在任何地方调用，但注意要传递applicationContext 。 iOS平台 （1）为什么要传pem证书? 答案: pem证书是和苹果建立连接时需要的文件，在用户上传时，信鸽后台会尝试连接苹果服务器验证其合法性。 （2）如果出现以下错误： 请在自己的项目里这样设置： （3）如果出现以下错误： 请在自己的项目里这样设置： provisioning profile文件需要包含正在调试的设备，并且provisioning profile文件要在app开启APNS之后生成。 （4）iOS为什么没有抵达数据？ 由于苹果系统的问题，信鸽无法统计到消息推送之后的抵达动作。但是，若用户对消息进行了点击，信鸽可以统计其点击动作并且上报。 受APNS和iOS的限制，效果统计功能可能会有一定的统计误差。 （5）无法上传iOS证书？ 请核对证书格式是否正确。 （6）证书验证失败？ 请仔细参考iOS证书设置指南进行证书制作。 （7）点击推送时，提示：failed to load certificate,check your APNS certificate a.对应环境的apns证书没提交 b.证书做得不对，请参照官方指南进行制作 c.推送环境是否选择正确，测试预览请选择开发环境 （8）开发证书和生产证书区别？ 开发证书用于开发推送服务时使用，设备获取到的deviceToken是苹果下发的开发环境的deviceToken。 生产证书用于正式的提送，苹果下发的是生产环境的deviceToken。AppStore审核通过后，可以给所有安装App的设备进行推送。 为什么我的项目接入信鸽在iphone5s上不能通过编译？ XCode进行以下设置即可,把相应Target的Valid Architectures里的arm64删除。 IOS 通过编译.jpg iOS SDK在注册xgpush时，出现下列情况是什么意思？ [xgpush seccess]rspCode is 0 [xgpush]Disconnected. 解答：第一个是指成功，第二个是指收到服务器返回或者超时，就会断开和服务器的连接。 （9）重新注册同一个别名收到推送消息？ 解答：setAccount之后要重新registerDevice一次，详细见注册设备 （10）创建标签推送失败，Debug日志中出现报错“有错误发生，服务器返回码：2 解答：这个是由于标签名称中包含空格导致的，标签名称中不能有空格。 （11）信鸽Android SDK关于集成厂商通道在开发调试过程中可能遇到的消息回调的问题 小米通道： 消息接收支持回调，消息点击支持回调(必须要自定义通知)，如果在信鸽前端推送消息时在【高级设置】中指定点击打开任一【应用】【自定义页面】【URL】【客户端自定义】之后，点击依然可以打开指定的页面，但是消息点击将不再支持回调，支持透传 华为通道： 消息接收暂不支持回调，消息点击支持回调(但必须添加自定义参数)，支持透传(但忽略自定义参数) 魅族通道： 消息接收支持回调，消息点击支持回调，不支持透传 以上涉及到暂不支持的特性是对应厂商的策略，信鸽会持续跟进厂商的变化 （12）信鸽Android SDK关于集成厂商通道在开发调试过程中可能遇到的otherpushToken = null的问题 小米通道排查路径： 1）根据开发文档检查manifest文件配置，尤其需要修改包名的地方有没修改： 2）在信鸽注册前有没有设置小米的appid和appkey，以及有没有启动第三方推送 // 启动第三方推送 XGPushConfig.enableOtherPush(this, true); // 设置小米的Appid和Appkey XGPushConfig.setMiPushAppId(this, MIPUSH_APPID); XGPushConfig.setMiPushAppKey(this, MIPUSH_APPKEY); 3）app的包名是否和小米推送官网上注册的包名一致 4）通过实现自定义的继承PushMessageReceiver的广播来监听小米注册的结果，查看注册返回码 5）启动logcat，观察tag为PushService的异常信息日志 华为通道排查路径： 1）检查【设置】->【应用管理】->【华为移动服务】的版本信息是否大于2.5.3 2）根据开发文档检查manifest文件配置是否正确 3）在信鸽注册之前，有没有启动第三方服务，以及华为APPID是否正确设置 "},"console.html":{"url":"console.html","title":"管理台功能介绍","keywords":"","body":"管理台工程介绍 在这个部分，我们介绍管理台提供的主要功能，使用方法，以及相关的数据口径内容 "},"console/auth.html":{"url":"console/auth.html","title":"权限管理","keywords":"","body":"管理台权限说明 一、角色分类&概述 1.管理员 定位：应用创建者、项目负责人、团队leader、开发等概述：拥有全平台权限，管理员有权删除应用，添加/删除/编辑其它角色，管理员之间可以互删等 2.运营人员 定位：平台的使用者、负责推送消息的成员概述：该角色可以推送消息、查看数据，但不能删除应用，不能添加/编辑/删除权限角色，也不能查看ACCESS KEY /SECRET KEY 3.查看人员 定位：平台数据的查看者，如：实习生、外包成员等概述：该角色仅具备查看数据的权限，不能创建推送，不能删除应用，不能添加修改权限角色等 二、角色权限说明 各角色具体权限明细如下： "},"console/pushdetail.html":{"url":"console/pushdetail.html","title":"推送详情","keywords":"","body":"推送详情 功能简介 推送详情功能帮助您在创建推送后，及时了解任务下发的进度&时间，推送转化率，覆盖面，以及推送时效性。当前支持对全量用户推送，标签推送的数据分析。 界面介绍 下发进度 对任务下发进行的实时统计，当任务开始下发后进行刷新。 推送转化分析 对于推送转化率的分析，可以分为Android和iOS两个平台。 [Android推送] 计划发送：当前应用30天内和服务器建立过连接的设备量 设备在线：在推送有效期内，和服务器进行了连接的设备数量（只有设备和服务器建立连接，消息才能被正常推出）到达：指到达终端设备中的消息Service数量展现：调用系统的消息展示接口，对消息进行展示的数量点击：点击通知栏消息的数量 [iOS推送] 计划推送：系统中所有有效设备的数量（当APNs返回Token无效时，系统会每天对这些无效设备进行清理）服务器下发：信鸽服务器真实下发的消息的设备数量APNs接收：APNs（苹果推送消息服务器）返回的收到消息的谁被数量\u0010点击：点击通知栏推送消息的数量 覆盖面分析 覆盖面分析，通过对推送到达量以及App活跃数量进行对比，衡量全量推送的覆盖面。（当前暂时只支持Android推送） 当日活跃覆盖率：推送任务的到达量/推送当日的DAU3日活跃覆盖率：推送任务的到达量/推送近三日的去重DAU 推送时效分析 推送时效分析，将推送统计按照时间维度进行细分，支持分钟颗粒度以及小时颗粒度，最大支持24的分时统计 "},"push_faq/noun_explanation.html":{"url":"push_faq/noun_explanation.html","title":"名词解释","keywords":"","body":"指标名词解释 应用列表 昨日连接设备：昨日有成功连接过信鸽服务器的设备数。 昨日卸载设备：昨日该应用被卸载的设备总数。信鸽可以统计到应用被卸载的动作，卸载一次上报一次，因此这里设备数未去重。 有效设备：当前处于注册状态（在信鸽注册成功）的设备数。 应用配置 应用包名：出于安全考虑，应用包名填写后不可更改；填写应用包名才能进行推送操作；应用包名是应用的Package Name，用于AndroidManifest.xml配置，比如com.tencent.news。 管理员：所有管理员权限一致，可以删除其他管理员但不可以删除自己。如果要转让管理员，建议先添加一个新的管理员，然后用新的管理员账号删除掉旧的账号以完成转让。 测试设备：测试设备用于推送消息之前先进行特定设备推送，以测试实际情况，确定无误之后再正式推送。测试设备的ID就是DeviceToken，通过logcat获取，具体请查阅开发者手册。 ACCESS KEY：客户端鉴权密钥，与Access ID共同验证以确定调用合法；需要配置到客户端SDK中，无法更换。 SECRET KEY：用于验证API调用，与APPKEY共同验证以确定调用合法。如果泄露，需要立即更换并重新配置客户端SDK。 ACCESS ID：识别一个应用的唯一标识，不能更改，需要配置到客户端SDK中，调用后台接口时也需要提供。 创建推送 推送内容：消息命令是应用接收后去执行的代码，具体代码形式由应用开发者自己定义。利用消息命令，可以远程控制应用各种行为，比如：应用下载并更换启动闪屏；修改移动游戏中物品的价格；静默更新应用内文字或者图片内容。 立即/定时推送：立即推送多适用于测试推送。定时推送多用于正式对外推送。 自定义参数：您还可以自定义设置键值对(key-value)，根据不同的键值对实现自定义需求。 离线保存：用户如果不在线，下次上线时可以收到推送，这里需要设定一个离线保存过期的时间，超过这个时间如果用户仍不在线，则不会收到这条推送。如果没有限时活动，强烈建议保存72小时！！！ 时段控制：设定用户可以接收推送的时段，您可以避免在夜间打扰用户，也可以设定在特定时间用户才能收到推送。 点击通知操作：设定用户点击通知之后的响应动作，可以直接打开应用，也可以指定打开应用的某个功能页面，还可以使用浏览器打开一个网址。 多包名推送：在多包名提示模式下，设备上所有使用这个access_id注册推送的app都会收到消息。该功能使用与区分不同渠道和包名的app。 推送列表 推送列表：展示的数据是全量/批量推送（属于广播类），点对点（单播类）推送不会展示在推送列表内。查看单播类推送，请前往“推送数据”页面。 推送时间：开始本条推送的时间。 Android-有效推送量：是指发送给当前在线设备（与服务器有连接的设备）的推送量。若消息设置了离线保存，随着时间的推移和用户的上线动作，有效推送量会有数值上的增加，即表示新上线的用户也收到了该条推送。 iOS-有效推送量：是指成功发送给苹果服务器的推送量。信鸽负责将消息成功推送给苹果服务器，但由于苹果服务器限制，抵达量无法统计。 抵达量：本条推送成功推送的用户数，实时数据有5分钟左右延迟。 撤销定时：撤销已经设定的，尚未发生的定时推送，撤消后该条推送将不再执行。 删除离线：是指删除后台存储的，即将发送的离线消息。成功删除离线消息后，这部分消息将不再发送。但是！！已经发送成功的消息不能进行删除。 推送数据 Android-有效推送量：是指发送给当前在线设备（与服务器有连接的设备）的推送量。若消息设置了离线保存，随着时间的推移和用户的上线动作，有效推送量会有数值上的增加，即表示新上线的用户也收到了该条推送。 iOS-有效推送量：是指成功发送给苹果服务器的推送量。信鸽负责将消息成功推送给苹果服务器，但由于苹果服务器限制，抵达量无法统计。 抵达量：本条推送成功推送的用户数，实时数据有5分钟左右延迟。 抵达率：抵达量/推送量×100% 点击量：成功的推送中，本条推送消息被点击次数的总计，点击量要求终端调用特定函数上报。 点击率：点击量/抵达量×100% 基础数据 日新增设备数：当天新注册的设备总数，需集成客户端SDK版本V2.3.6及以上 日卸载设备数：当天卸载应用的设备总数，需要集成客户端SDK版本V2.3.6及以上 日连接设备数：当天连接过信鸽服务器的设备总数 我的标签 标签：通常是指给某个或某一群用户打上标签。自定义标签可以通过客户端或服务端调用进行设置，之后在前台进行使用。 高级数据标签：是指信鸽通过数据整理，直接为特定用户打上标签。高级标签仅供使用，无法编辑或删除。 "},"apicloud-tencentpush.html":{"url":"apicloud-tencentpush.html","title":"APICloud模块接入(new)","keywords":"","body":"APICloud 模块概述 本模块封装腾讯信鸽推送的SDK，只需要1行代码便可实现免费、实时、专业的推送功能，支持通知、消息透传、本地通知、账号绑定、默认标签等，目前支持Android，iOS平台。详情请见： APICloud 模块使用指引 "}}